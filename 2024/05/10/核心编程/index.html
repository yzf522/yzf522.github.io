<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++面向对象编程 | 小楼夜听雨</title><meta name="keywords" content="C++"><meta name="author" content="小楼夜听雨"><meta name="copyright" content="小楼夜听雨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++面向对象编程"><meta name="application-name" content="C++面向对象编程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++面向对象编程"><meta property="og:url" content="http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="小楼夜听雨"><meta property="og:description" content="内存分区模型C++程序在执行时，将内存大方向划分为4个区域  代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义："><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2024/12/29/677157b8efbea.webp"><meta property="article:author" content="小楼夜听雨"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2024/12/29/677157b8efbea.webp"><meta name="description" content="内存分区模型C++程序在执行时，将内存大方向划分为4个区域  代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义："><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 缓缓飘落的枫叶想思念"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小楼夜听雨","link":"链接: ","source":"来源: 小楼夜听雨","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小楼夜听雨',
  title: 'C++面向对象编程',
  postAI: '',
  pageFillDescription: '内存分区模型, 程序运行前, 程序运行后, new操作符和在堆区开辟数组, 引用, 引用的基本使用, 引用注意事项, 引用做函数参数(引用传递), 引用做函数返回值, 引用的本质, 常量引用, 函数提高, 函数默认参数, 函数占位参数, 函数重载, 函数重载概述, 函数重载注意事项, 类和对象, 封装, 封装的意义, 封装意义一：设计类, 封装意义二：封装的权限控制, struct和class区别, 成员属性设置为私有, 对象的初始化和清理, 构造函数和析构函数, 构造函数的分类及调用, 拷贝构造函数调用时机, 构造函数调用规则, 深拷贝与浅拷贝, 初始化列表, 类对象作为类成员, 静态成员, C++对象模型和this指针, 成员变量和成员函数分开存储, this指针概念, 空指针访问成员函数, const修饰成员函数, 友元, 全局函数做友元, 类做友元, 成员函数做友元, 运算符重载, 加号运算符重载, 左移运算符重载, 递增运算符重载, 赋值运算符重载, 关系运算符重载, 函数调用运算符重载, 继承, 继承的基本语法, 继承方式, 继承中的对象模型, 继承中构造和析构顺序, 继承同名成员处理方式, 继承同名静态成员处理方式, 多继承语法, 菱形继承, 多态, 多态的基本概念, 纯虚函数和抽象类, 虚析构和纯虚析构, 案例, 文件操作, 文本文件, 写文件, 读文件, 二进制文件, 写文件, 读文件, 核心篇完结撒花内存分区模型程序在执行时将内存大方向划分为个区域代码区存放函数体的二进制代码由操作系统进行管理的全局区存放全局变量和静态变量以及常量栈区由编译器自动分配释放存放函数的参数值局部变量等堆区由程序员分配和释放若程序员不释放程序结束时由操作系统回收内存四区意义不同区域存放的数据赋予不同的生命周期给我们更大的灵活编程程序运行前在程序编译后生成了可执行程序未执行该程序前分为两个区域代码区存放执行的机器指令代码区是共享的共享的目的是对于频繁被执行的程序只需要在内存中有一份代码即可代码区是只读的使其只读的原因是防止程序意外地修改了它的指令全局区全局变量和静态变量存放在此全局区还包含了常量区字符串常量和其他常量也存放在此该区域的数据在程序结束后由操作系统释放全局变量不在函数体中定义的变量修饰的全局变量全局常量全局区全局变量静态变量常量局部变量在函数体内定义的变量局部变量的地址为局部变量的地址为全局变量的地址为全局变量的地址为静态变量在普通变量的前面加静态变量的地址为静态变量的地址为常量字符串常量修饰的常量修饰的局部变量局部常量字符串常量的地址为全局常量的地址为局部常量的地址为不在全局区总结在局部的和局部常量都不在全局区全局变量静态变量字符串常量全局常量在全局区总结中在程序运行前分为全局区和代码区代码区特点是共享和只读全局区中存放全局变量静态变量常量常量区中存放修饰的全局常量和字符串常量程序运行后栈区由编译器自动分配释放存放函数的参数值局部变量等注意事项不要返回局部变量的地址栈区开辟的数据由编译器自动释放堆区由程序员分配释放若程序员不释放程序结束时由操作系统回收在中主要利用在堆区开辟内存形参数据也会放在栈区局部变量存放在栈区栈区的数据在函数执行完后自动释放返回局部变量地址开辟堆区利用关键字可以将数据开辟到堆区指针是局部变量而指针保存的数据是放在堆区程序运行后会划分栈区和堆区栈区由编译器自动分配释放存放函数的参数值局部变量等注意不要返回局部变量的地址栈区开辟的数据由编译器自动释放野指针警告第一次可以打印正确的数字是因为编译器做了保留第二次这个数据就不再保留了在位的情况下对返回值进行了优化进行了保留堆区由程序员分配释放若程序员不释放程序结束时由操作系统回收在中主要利用在堆区开辟内存指针已经捕获了在堆区的地址所以在栈区的指针变量即使被释放也不影响总结堆区数据由程序员管理开辟和释放堆区数据利用关键字进行开辟内存操作符和在堆区开辟数组中利用操作符在堆区开辟数据堆区开辟的数据由程序员手动开辟手动释放释放利用操作符释放堆区数组的时候要加语法数据类型利用创建的数据会返回该数据对应的类型的指针利用操作符在堆区开辟数据堆区由程序员分配释放可以手动释放使用操作符如果这个时再访问就是非法操作野指针在堆区利用开辟数组利用代表个元素返回的是数组的首地址释放堆区数组的时候要加中利用操作符在堆区开辟数据可以手动释放使用操作符利用创建数据会返回该数据对应的类型的指针引用引用的基本使用作用给变量起别名语法数据类型别名原名示例引用给变量起别名别名和原名都代表同一个内存空间语法数据类型别名原名引用注意事项引用必须初始化引用在初始化后不可以改变示例引用必须初始化引用在初始化后不可以改变可以赋值一旦代表一段内存空间后就不可更改是错误的是错误的引用做函数参数引用传递作用函数传参时可以利用引用的技术让形参修饰实参优点可以简化指针修改实参示例引用传递引用做形参的时候不用初始化函数传参时可以利用引用的技术让形参修饰实参可以简化指针修改实参总结通过引用参数产生的效果同按地址传递是一样的引用的语法更清楚简单引用做函数返回值作用引用是可以作为函数的返回值存在的该函数就是引向返回值的地址函数名本身就是别名注意不要返回局部变量引用用法函数调用作为左值示例引用做函数返回值不要返回局部变量的引用局部变量存放在栈区函数的调用可以作为左值静态变量存放在全局区全局区上的数据在程序结束后系统释放生命周期加长第一次可以打印正确的数字是因为编译器做了保留已经是的别名如果函数的返回值是引用这个函数调用可以作为左值引用的本质本质引用的本质在内部实现是一个指针常量示例发现是引用转换为是引用转换为自动转换为指针常量是指针指向不可改也说明为什么引用不可更改内部发现是引用自动帮我们转换为结论推荐用引用技术因为语法方便引用本质是指针常量但是所有的指针操作编译器都帮我们做了常量引用作用常量引用主要用来修饰形参防止误操作在函数形参列表中可以加修饰形参防止形参改变实参示例打印函数常量引用引用可修改常量不可修改不可修改防止误操作常量引用使用场景用来修饰形参防止误操作引用必须引向一块合法内存空间加上之后编译器将代码修改指的是一块临时空间之后改为只读不可修改函数提高函数默认参数在中函数的形参列表中的形参是可以有默认值的语法返回值类型函数名参数默认值示例函数的默认参数如果没有传入参数则使用默认使用形参的默认值语法返回值类型函数名形参默认值注意如果某个位置已经有了默认值那么从这个位置往后从左到右都必须有默认值注意如果某个位置已经有了默认值那么从这个位置往后从左到右都必须有默认值会报错注意如果函数声明有默认参数函数实现就不能有默认参数会重复定义默认参数声明和实现只能一个有默认参数注意如果某个位置已经有了默认值那么从这个位置往后从左到右都必须有默认值注意如果函数声明有默认参数函数实现就不能有默认参数会重复定义默认参数声明和实现只能一个有默认参数函数占位参数中函数的形参列表里可以有占位参数用来做占位调用函数时必须填补该位置语法返回值类型函数名数据类型在现阶段函数的占位参数存在意义不大但是后面的课程中会用到该技术示例占位参数返回值类型函数名数据类型目前阶段的占位参数我们还用不到后面函数重载会用到占位参数也可以有默认参数更没有用了滑稽函数重载函数重载概述作用函数名可以相同提高复用性函数重载满足条件同一个作用域下函数名称相同函数参数类型不同或者个数不同或者顺序不同根据不同的调用参数会自动使用对应的函数注意函数的返回值不可以作为函数重载的条件示例函数重载可以使函数名相同提高复用性函数重载的满足条件同一个作用域下全局或者其他函数名称相同函数的参数类型不同或者个数不同或者顺序不同根据不同的调用参数会自动使用对应的函数的调用的调用的调用的调用的调用注意函数的返回值类型不可以作为函数重载的条件因为如果参数相同就无法区分调用哪个函数内容因为返回值可以不接收输出的调用的调用根据不同的调用参数会自动使用对应的函数注意函数的返回值类型不可以作为函数重载的条件因为如果参数相同就无法区分调用哪个函数内容因为返回值可以不接收输出函数重载注意事项引用作为重载条件函数重载碰到函数默认参数示例函数重载注意事项引用作为重载条件的引用有引用这个类型的时候不能定义相同类型的形参不合法的引用的数据被传进来后只能读不能写的引用合法会创造一个临时空间存放数据并引向临时空间函数重载碰到默认参数会出现二义性歧义语法本身没有问题不调用就不会报错写重载的时候尽量避免写默认参数的引用的引用的值是变量可读可写所以会被的函数调用常量不可被修改所以会被的函数调用只能引向合法的内存地址两个都可以传入参数编译器我机傻了滑稽参数完整的时候可以运行注意有引用这个类型的形参的时候不能定义相同类型的形参类和对象面向对象的三大特性为封装继承多态认为万事万物都皆为对象对象上有其属性和行为属性和行为统一称为成员属性也叫成员属性成员变量行为也叫成员函数成员方法例如人可以作为对象属性有姓名年龄身高体重行为有走跑跳吃饭唱歌车也可以作为对象属性有轮胎方向盘车灯行为有载人放音乐放空调具有相同性质的对象我们可以抽象称为类人属于人类车属于车类封装封装是面向对象三大特性之一封装的意义将属性和行为作为一个整体表现生活中的事物将属性和行为加以权限控制封装的意义封装意义一设计类在设计类的时候属性和行为写在一起表现事物语法类名访问权限属性行为示例设计一个圆类求圆的周长示例代码面向对象的三大特性为封装继承多态认为万事万物都皆为对象对象上有其属性和行为统一称为成员具有相同性质的对象我们可以抽象称为类属性和行为统一称为成员属性也叫成员属性成员变量行为也叫成员函数成员方法圆周率设计一个圆类求圆的周长访问权限公共权限属性半径变量行为获取圆的周长函数封装的意义将属性和行为作为一个整体表现生活中的事物将属性和行为加以权限控制将属性和行为作为一个整体表现生活中的事物在设计类的时候属性和行为写在一起表现事物语法类名访问权限属性行为通过圆类创建具体的圆对象实例化给圆的对象的属性进行赋值圆的周长为将属性和行为加以权限控制公共权限成员类内外都可访问保护权限成员类内可以访问类外不可访问在继承中子可以访问父中的保护内容私有权限成员类内可以访问类外不可访问在继承中子不可以访问父中的私有内容一般情况下我们把类的声明部分写在自定义的头文件上把类的实现部分写在一个单独的源文件内以简化主函数源文件的代码数量详细内容看案例练习部分封装意义二封装的权限控制类在设计时可以把属性和行为放在不同的权限下加以控制访问权限有三种公共权限成员类内外都可访问保护权限成员类内可以访问类外不可访问在继承中子可以访问父中的保护内容私有权限成员类内可以访问类外不可访问在继承中子不可以访问父中的私有内容公共权限姓名保护权限车的密码私有权限银行卡密码如果函数不是公共权限也不可访问在类内所以权限都可以访问张三将属性和行为加以权限控制公共权限成员类内外都可访问保护权限成员类内可以访问类外不可访问在继承中子可以访问父中的保护内容私有权限成员类内可以访问类外不可访问在继承中子不可以访问父中的私有内容王五不可访问不可访问和区别在中和唯一的区别就在于默认的访问权限不同区别默认权限为公共默认权限为私有默认权限为私有在中和的唯一区别就在于默认访问权限不同默认权限为公共默认权限为私有默认权限所有不可访问默认权限公共可以访问成员属性设置为私有优点将所有成员属性设置为私有可以自己控制读写权限优点对于写权限我们可以检测数据的有效性示例写入姓名的函数读取姓名的函数读取年龄的函数写入偶像的函数写入年龄输入有误姓名可读可写年龄只读可以默认如果年龄可写则要限定范围要检测数据有效性偶像只写张三对象的初始化和清理生活中我们买的电子产品都基本会有出厂设置在某一天我们不用时候也会删除一些自己信息数据保证安全中的面向对象来源于生活每个对象也都会有初始设置以及对象销毁前的清理数据的设置构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题一个对象或者变量没有初始状态对其使用后果是未知同样的使用完一个对象或变量没有及时清理也会造成一定的安全问题利用了构造函数和析构函数解决上述问题这两个函数将会被编译器自动调用完成对象初始化和清理工作对象的初始化和清理工作是编译器强制要我们做的事情因此如果我们不提供构造和析构编译器会提供编译器提供的构造函数和析构函数是空实现构造函数主要作用在于创建对象时为对象的成员属性赋值构造函数由编译器自动调用无须手动调用析构函数主要作用在于对象销毁前系统自动调用执行一些清理工作构造函数语法类名构造函数没有返回值也不写函数名称与类名相同构造函数可以有参数因此可以发生重载程序在调用对象时候会自动调用构造无须手动调用而且只会调用一次析构函数语法类名析构函数没有返回值也不写函数名称与类名相同在名称前加上符号析构函数不可以有参数因此不可以发生重载程序在对象销毁前会自动调用析构无须手动调用而且只会调用一次对象的初始化和清理构造函数进行初始化操作构造函数没有返回值不用写函数名与类名相同构造函数可以有参数可以发生重载创造对象的时候构造函数会自动调用而且只调用一次构造函数的调用析构函数进行清理的操作没有返回值不写函数名和类名相同在名称前面加没有参数不可以发生重载对象在销毁前会自动调用析构函数而且只会调用一次析构函数的调用构造和析构都是必须有的实现如果我们自己不提供编译器会提供一个空实现的构造和析构在栈区的数据在执行完之后释放这个对象在程序结束运行后会执行析构函数构造函数的分类及调用两种分类方式按参数分为有参构造和无参构造按类型分为普通构造和拷贝构造三种调用方式括号法显示法隐式转换法示例构造函数的分类和调用分类按照参数分类无参构造默认构造和有参构造按照类型分类普通构造拷贝构造构造函数无参构造函数的调用有参构造函数的调用拷贝构造如果值传递则会创建一个副本将对象的属性复制过来当一个对象需要以值方式传递时编译器会生成代码调用它的拷贝构造函数以生成一个复本如果类的拷贝构造函数是以值方式传递一个类对象作为参数的话当需要调用类的拷贝构造函数时需要以值方式传进一个的对象作为实参而以值方式传递需要调用类的拷贝构造函数结果就是调用类的拷贝构造函数导致又一次调用类的拷贝构造函数这就是一个无限递归将传入的人身上的所有属性拷贝的我当前对象身上拷贝构造函数的调用析构函数的调用调用括号法默认构造函数调用有参构造函数调用拷贝构造函数的调用的年龄的年龄注意默认构造函数调用不要加小括号会被认为是一个声明显示法匿名对象特点当前行执行结束后系统会立刻回收匿名对象不要利用拷贝构造函数初始化匿名对象编译器会认为对象声明隐式转化法相当于写了有参构造拷贝构造函数注意拷贝函数必须是引用传递否则会无限递归拷贝构造函数调用时机中拷贝构造函数调用时机通常有三种情况使用一个已经创建完毕的对象来初始化一个新对象值传递的方式给函数参数传值以值方式返回局部对象示例使用时机使用一个已经创建完毕的对象来初始化一个新对象值传递的方式给函数参数传值值的方式返回局部对象构造函数无参构造函数的调用有参构造函数的调用拷贝构造函数的调用析构函数的调用使用一个已经创建完毕的对象来初始化一个新对象的年龄值传递的方式给函数形参参数传值值传递会调用拷贝函数进行创建副本拷贝将的属性值传递给形参值的方式返回局部对象的年龄不会调用拷贝构造函数返回本身所以地址一样会调用拷贝构造函数返回地址不一样的年龄构造函数调用规则默认情况下编译器至少给一个类添加个函数默认构造函数无参函数体为空默认析构函数无参函数体为空默认拷贝构造函数对属性进行值拷贝构造函数调用规则如下如果用户定义有参构造函数不在提供默认无参构造但是会提供默认拷贝构造如果用户定义拷贝构造函数不会再提供其他构造函数示例构造函数的调用规则创建一个类编译器会给每个类都至少添加个函数默认构造空实现析构函数空实现拷贝构造值拷贝如果我们写了有参构造函数编译器就不再提供默认构造依然通过拷贝构造如果我们写了拷贝构造函数编译器就不再提供构造函数构造函数的调用有参构造函数的调用拷贝构造函数的调用析构函数的调用默认的值拷贝的年龄如果我们写了有参构造函数编译器就不再提供默认构造依然通过拷贝构造默认的值拷贝的年龄深拷贝与浅拷贝深浅拷贝是面试经典问题也是常见的一个坑浅拷贝简单的赋值拷贝操作浅拷贝的问题就是堆区的重复释放深拷贝在堆区重新申请空间进行拷贝操作示例深拷贝和浅拷贝浅拷贝的问题就是堆区的重复释放深拷贝就是自己写一个拷贝构造函数拷贝的时候创建一个新的堆区防止将对象的指针地址拷贝过来构造函数的调用有参构造函数的调用析构代码将堆区开辟的数据做释放操作如果身高的指针不等于空释放堆区的数据防止野指针的出现析构函数的调用将对象的指针解引用的值放进堆区并将堆区地址赋给当前的指针如果是系统默认的浅拷贝会把指针地址也拷贝过去但是当一个类的这个指针被释放之后再次释放就是非法操作报错栈区规则先进后出进进出出的年龄的身高总结如果属性有在堆区开辟的一定要自己提供拷贝构造函数防止浅拷贝带来的问题初始化列表作用提供了初始化列表语法用来初始化属性语法构造函数属性值属性值示例初始化列表初始化属性类名有无参属性初始值属性初始值实现传统初始化初始化列表初始化属性是一种无参构造函数实现有参构造函数类对象作为类成员类中的成员可以是另一个类的对象我们称该成员为对象成员例如类对象作为类成员当其他类对象作为本类的成员在构造的时候先构造其他类对象再构造自身先有零件再有本体析构函数按照栈区规则先进后出先析构本体再析构零件手机的构造函数调用手机析构函数的调用隐式转化法人的构造函数调用人析构函数的调用姓名手机张三苹果静态成员静态成员就是在成员变量和成员函数前加上关键字称为静态成员静态成员分为静态成员变量所有对象共享同一份数据在编译阶段分配内存类内声明类外初始化静态成员函数所有对象共享同一个函数静态成员函数只能访问静态成员变量示例静态成员变量末影箱里面的物品的数据静态成员变量所以对象都共享同一份数据相当于末影箱里的物品的数据编译阶段就分配了内存类内声明类外初始化操作静态成员变量也是有访问权限的类外初始化操作所以对象都共享同一份数据相当于末影箱静态成员变量不属于某个对象上所有对象都共享同一份数据因此静态成员变量有两种访问方式通过对象进行访问通过类名进行访问错误没有访问权限示例静态成员函数末影箱只能访问末影箱物品的数据不能访问箱子的数据静态成员函数相当于末影箱只能访问末影箱的数据不能访问箱子的数据所以对象共享一个函数静态成员函数只能访问静态成员变量静态成员函数只能访问静态成员变量静态成员函数不能访问非静态成员变量因为静态函数是所以对象共享的如果一个对象调用的时候函数不知道访问哪个对象的非静态变量静态函数的调用非静态成员变量静态成员函数也是有访问权限的静态函数的调用类外初始化操作访问方法通过对象访问报错静态成员函数也是有访问权限的通过类名访问对象模型和指针成员变量和成员函数分开存储在中类内的成员变量和成员函数分开存储只有非静态成员变量才属于类的对象上成员变量和成员函数分开储存非静态成员变量属于类的对象上静态成员变量不属于类的对象上只有一份非静态成员函数不属于类的对象上只有一份静态成员函数不属于类的对象上只有一份空对象占用的内存空间为编译器会给每个空对象也分配一个字节的空间是为了区分空对象占内存的位置每个空对象也应该有一个独一无二的内存地址空对象的内存多大有的对象的内存多大指针概念通过上面我们知道在中成员变量和成员函数是分开存储的每一个非静态成员函数只会诞生一份函数实例也就是说多个同类型的对象会共用一块代码那么问题是这一块代码是如何区分那个对象调用自己的呢通过提供特殊的对象指针指针解决上述问题指针指向被调用的成员函数所属的对象指针是隐含每一个非静态成员函数内的一种指针指针不需要定义直接使用即可指针的用途当形参和成员变量同名时可用指针来区分在类的非静态成员函数中返回对象本身可使用指针指向被调用成员函数所属的对象解决名称冲突返回对象本身用解决名称冲突指向被调用成员函数所属的对象以引用的方式返回如果不用引用就是值返回就是拷贝本体实际上返回的是副本如果还返回就是是副本的副本所以后面的就和没有关系了指向的指针表示的本体解决名称冲突的年龄返回对象本身用链式编程思想函数返回的本体所以可以增加进行操作的年龄空指针访问成员函数中空指针也是可以调用成员函数的但是也要注意有没有用到指针如果用到指针需要加以判断保证代码的健壮性空指针调用成员函数这个类的名称叫会报错因为指针是空指针解决方法这个人的年龄前面默认有一个空指针修饰成员函数常函数成员函数后加后我们称为这个函数为常函数常函数内不可以修改成员属性成员属性声明时加关键字后在常函数中依然可以修改常对象声明对象前加称该对象为常对象常对象只能调用常函数示例常函数在成员函数括号后面加常对象常函数指针的本质是指针常量指向不可修改是错误的在成员函数后面加修饰的是指针让指针指向的值也不可修改特殊变量即使在常函数中也可以修改这个值在前面加关键字常对象在对象前加上常对象的正常属性不允许修改加了的特殊变量在常对象下也可以修改常对象只能调用常函数因为普通成员函数里面是可以修改属性的值的所以不能调用普通成员函数友元生活中你的家有客厅有你的卧室客厅所有来的客人都可以进去但是你的卧室是私有的也就是说只有你能进去但是呢你也可以允许你的好闺蜜好基友进去在程序里有些私有属性也想让类外特殊的一些函数或者类进行访问就需要用到友元的技术友元的目的就是让一个函数或者类访问另一个类中私有成员友元的关键字为友元的三种实现全局函数做友元类做友元成员函数做友元全局函数做友元全局函数做友元建筑物类函数声明全局函数是类的好朋友可以访问私有成员客厅卧室客厅卧室全局函数好基友好基友的全局函数正在访问好基友的全局函数正在访问类做友元类做友元在堆区开辟一个建筑物对象用接收参观函数通过访问指针访问在堆区的建筑物对象建筑物类类声明类是类的好朋友可以访问私有成员将客厅和卧室初始化给下面的变量客厅卧室类外写成员函数注意要类内声明客厅卧室好基友的类正在访问好基友的类正在访问成员函数做友元成员函数做友元让参观函数访问建筑物类的内容让参观函数访问建筑物类的内容不让参观函数访问建筑物类函数声明和作用域类下的成员函数是类的好朋友可以访问私有成员客厅卧室类外写成员函数注意要类内声明客厅卧室必须定义在后面否则无法访问所以最好声明在类内定义在类外好基友的成员函数正在访问好基友的成员函数正在访问好基友的成员函数正在访问好基友的成员函数正在访问报错没有权限访问运算符重载运算符重载概念对已有的运算符重新进行定义赋予其另一种功能以适应不同的数据类型加号运算符重载作用实现两个自定义数据类型相加的运算加号运算符重载可以让自定义的数据类型相加成员函数重载号全局函数重载号成员函数重载号全局函数重载号函数重载的版本成员函数重载本质调用全局函数重载的本质调用简化版本运算符重载也可以发生函数重载总结对于内置的数据类型的表达式的的运算符是不可能改变的总结不要滥用运算符重载左移运算符重载作用可以输出自定义数据类型左移运算符重载可以让自定义的数据类型相加全局函数重载本质是函数也可以友元提供构造函数进行初始化成员函数重载因为无法实现在左侧所以不会利用成员函数重载运算符只能运用全局函数重载是标准的输出流对象类型是输出流而且全局只能有一个所以要引用是标准的输入流对象类型是输入流而且全局只能有一个所以要引用的拷贝函数不允许使用所以值返回时要引用直接返回类型地址的这里的可以使用其他别名如因为实际传入的实参是如果不返回则无法使用链式编程全局函数重载的本质调用总结重载左移运算符配合友元可以实现输出自定义数据类型递增运算符重载作用通过重载递增运算符实现自己的整型数据递增运算符重载定义一个整形成员函数重载前置后置这个是占位参数编译器用来区分前置和后置记录传入时的数据进行操作返回记录的数据因为我们返回的是在栈区的临时对象副本这个函数执行完会销毁所以不能引用返回和接收临时对象是右值不能进行引用不可修改因此不能链式如果开辟到堆区呢实测不行重载左移运算符因为我们返回的是在栈区的临时对象副本这个函数执行完会销毁所以不能引用返回和接收总结前置递增返回引用后置递增返回值赋值运算符重载编译器至少给一个类添加个函数默认构造函数无参函数体为空默认析构函数无参函数体为空默认拷贝构造函数对属性进行值拷贝赋值运算符对属性进行值拷贝如果类中有属性指向堆区做赋值操作时也会出现深浅拷贝问题示例赋值运算符重载编译器自身提供的是浅拷贝不能使用值传递不然会生成副本复制将的指针复制然后结束后析构这样就释放了堆区后面再释放的就会出错直接赋值就是浅拷贝两次释放了堆区的年龄是的年龄是的年龄是关系运算符重载作用重载关系运算符可以让两个自定义类型对象进行对比操作示例关系运算符重载让两个自定义类型对象进行对比操作重载重载张三李四王五相等不相等不相等相等函数调用运算符重载函数调用运算符也可以重载由于重载后使用的方式非常像函数的调用因此称为仿函数仿函数没有固定写法非常灵活示例函数调用运算符重载由于重载后的使用方式非常像函数的调用也叫仿函数没有固定写法非常灵活打印函数类重载函数运算符由于重载后的使用方式非常像函数的调用也叫仿函数仿函数没有固定写法非常灵活加法类匿名函数对象类名使用完之后立即销毁不用实例化对象就可以使用仿函数继承继承是面向对象三大特性之一我们发现定义这些类下级别的成员除了拥有上一级的共性还有自己的特性这个时候我们就可以考虑利用继承的技术减少重复代码继承的基本语法例如我们看到很多网站中都有公共的头部公共的底部甚至公共的左侧列表只有中心内容不同接下来我们分别利用普通写法和继承的写法来实现网页中的内容看一下继承存在的意义以及好处我们定义类的时候类和类之间有特殊关系下级别的成员除了有自己的特性也有上级的共性利用继承可以减少重复代码语法子类继承方式父类子类也称为派生类父类也称为基类例如网站有公共的头部和底部只有中心内容不一样普通实现页面首页公开课登录注册公共头部帮助中心交流合作站内地图公共底部公共分类列表的学科视频页面首页公开课登录注册公共头部帮助中心交流合作站内地图公共底部公共分类列表的学科视频继承实现页面在需要继承的子类名后面加上父类名公共页面类首页公开课登录注册公共头部帮助中心交流合作站内地图公共底部公共分类列表页面的学科视频页面的学科视频页面的下载视频页面如下页面的下载视频页面如下总结继承的好处可以减少重复的代码类称为子类或派生类类称为父类或基类派生类中的成员包含两大部分一类是从基类继承过来的一类是自己增加的成员从基类继承过过来的表现其共性而新增的成员体现了其个性继承方式继承的语法子类继承方式父类继承方式一共有三种公共继承保护继承私有继承示例继承方式父类的私有内容不可继承公有继承直接拷贝公有和保护内容保护继承拷贝公有和保护内容变成保护内容私有继承拷贝公有和保护内容变成私有内容父类公有继承父类中的公共权限成员到子类中依然是公共权限父类中的保护权限成员到子类中依然是保护权限父类中的私有权限成员子类访问不到保护继承父类中的公共权限成员到子类中变成保护权限父类中的保护权限成员到子类中依然是保护权限父类中的私有权限成员子类访问不到私有继承父类中的公共权限成员到子类中变成私有权限父类中的保护权限成员到子类中依然是私有权限父类中的私有权限成员子类访问不到公有继承私有继承的类孙子公有继承爷爷私有继承给父亲的内容父类中的私有权限成员子类访问不到父类中的私有权限成员子类访问不到父类中的私有权限成员子类访问不到公有继承后保护权限还是保护权限不可在类外访问保护继承后全部变成保护权限不可在类外访问保护继承后全部变成私有权限不可在类外访问继承中的对象模型问题从父类继承过来的成员哪些属于子类对象中示例从父类继承过来的成员哪些属于子类对象中父类中所以的非静态成员属性都会被子类继承下去父类中私有成员属性是被编译器隐藏了因此是访问不到但是确实被继承下去了隐形基因继承了压缩包但不知道密码在开始菜单里可以找到的开发人员命令提示符打开之后先跳所在的转盘符如粘贴所在地址是跳转输入想查看的类名的部分名加键补全利用工具查看在开始菜单里可以找到的开发人员命令提示符打开之后先跳所在的转盘符如粘贴所在地址是跳转输入想查看的类名的部分名加键补全之后就可以得到结论父类中私有成员也是被子类继承下去了只是由编译器给隐藏后访问不到继承中构造和析构顺序子类继承父类后当创建子类对象也会调用父类的构造函数问题父类和子类的构造和析构顺序是谁先谁后示例子类继承父类之后当子类创建对象也会调用父类的构造函数父类和子类的构造和析构谁先谁后父类的构造函数父类的析构函数子类的构造函数子类的析构函数父类的构造函数先创造父类才能继承子类的构造函数在创造子类并继承子类的析构函数栈区先进后出完成操作后析构父类的析构函数栈区先进后出完成操作后析构结论构造先有爸爸再有儿子析构白发人送黑发人结论构造先有爸爸再有儿子析构白发人送黑发人继承同名成员处理方式问题当子类与父类出现同名的成员如何通过子类对象访问到子类或父类中同名的数据呢访问子类同名成员直接访问即可访问父类同名成员需要加作用域示例当子类与父类出现同名的成员如何通过子类对象访问子类或者父类中同名的数据访问子类对象直接访问即可访问父类对象需要加作用域张三我是练习时长两年半的个人练习生蔡徐坤同名重载函数我是练习时长两年半的个人练习生坤坤李四卧槽是鸡哥成员变量如果通过子类对象访问父类中的同名成员变量需要加作用域成员函数如果通过子类对象访问父类中的同名成员函数需要加作用域如果子类中出现和父类同名的成员函数子类的同名成员函数会因此掉父类中所有同名函数重载如果想要访问父类中被隐藏的同名成员函数需要加作用域总结子类对象可以直接访问到子类中同名成员子类对象加作用域可以访问到父类同名成员当子类与父类拥有同名的成员函数子类会隐藏父类中同名成员函数加作用域可以访问到父类中同名函数继承同名静态成员处理方式问题继承中同名的静态成员在子类对象上如何进行访问静态成员和非静态成员出现同名处理方式一致访问子类同名成员直接访问即可访问父类同名成员需要加作用域示例继承中同名的静态成员在子类对象上如何访问静态成员和非静态成员出现同名处理方式一致访问子类同名直接访问访问父类同名加作用域这是父类静态函数这是父类重载静态函数这是子类静态函数这是父类静态变量这是子类静态变量通过对象访问通过对象访问如果子类中出现和父类同名的成员函数子类的同名成员函数会因此掉父类中所有同名函数重载静态如果想要访问父类中被隐藏的同名成员函数需要加作用域通过类名访问第一个代表通过类名方式访问第二个代表访问父类作用域下通过类名访问总结同名静态成员处理方式和非静态处理方式一样只不过有两种访问的方式通过对象和通过类名多继承语法允许一个类继承多个类语法子类继承方式父类继承方式父类多继承可能会引发父类中有同名成员出现需要加作用域区分实际开发中不建议用多继承示例允许一个类继承多个类吕布这个我熟狗头语法子类继承方式父类继承方式父类多继承可能会引发父类中有同名成员出现需要加作用域区分实际开发中不建议用多继承出现两个父类中有同名的情况会导致对象不明确二义性需要加作用域总结多继承中如果父类中出现了同名情况子类使用时候要加作用域菱形继承菱形继承概念两个派生类继承同一个基类又有某个类同时继承者两个派生类这种继承被称为菱形继承或者钻石继承菱形继承问题羊继承了动物的数据驼同样继承了动物的数据当草泥马使用数据时就会产生二义性草泥马继承自动物的数据继承了两份其实我们应该清楚这份数据我们只需要一份就可以示例菱形继承砖石继承爷爷我有个儿子孙子我有个爸爸问题二义性孙子继承了爷爷的两份数据但是我们只要一份就可以了利用虚继承可以解决菱形继承问题在继承之前加上关键字变成虚继承父类称为虚基类动物类羊类驼类羊驼类二义性当菱形继承两个父类拥有相同的数据需要加以作用域区分这份数据我们知道只要有一份就可以了菱形继承导致数据有两份资源浪费虚继承之后数据只有一份总结菱形继承带来的主要问题是子类继承两份相同的数据导致资源浪费以及毫无意义利用虚继承可以解决菱形继承问题子类再继承的时候也是传的虚基类指针无论多少成员都是通过指针找到的都是一开始继承的对象的唯一值多态多态的基本概念多态是面向对象三大特性之一多态分为两类静态多态函数重载和运算符重载属于静态多态复用函数名动态多态派生类和虚函数实现运行时多态静态多态和动态多态区别静态多态的函数地址早绑定编译阶段确定函数地址动态多态的函数地址晚绑定运行阶段确定函数地址多态是面向对象的三大特性之一静态多态函数重载和运算符重载复用函数名函数地址早绑定编译阶段确定函数地址动态多态派生类和虚函数实现运行时多态函数地址晚绑定运行阶段确定函数地址动态多态的满足条件有继承关系子类要重写父类的虚函数返回返回值类型函数名参数列表完全相同使用父类的引用或者指针指向子类对象虚函数如果不加就是重复函数名函数的地址在编译的时候就已经绑定在运行的时候调用这个函数就会执行这个地址下的实现动物在说话小猫在说话小狗在说话父类引用指向子类对象通过虚函数继承之后的函数地址就不确定了需要在运行的时候绑定底层原理在父类定义了一个虚函数的时候会生成一个虚函数表指针和虚函数表指针在类内内存为表不在类内需要指针指向虚函数表在记录了指向该类中所有虚函数的指针继承的时候子类也会继承虚函数表和虚函数表指针但是在子类中重写虚函数的时候子类中虚函数表中原本父类的虚函数的指针就会被覆盖但是父类中的虚函数表不变当父类的指针或者引用指向子类对象的时候会通过虚函数表指针来确定被传入类中的虚函数表如果被传入类中的虚函数表没有重写就会通过里面原本记录的父类的虚函数的指针找到虚函数并且执行如果被传入类中的虚函数表已经重写就会通过里面子类的虚函数的指针找到虚函数并且执行以父类的指针或者引用进行传入以本人的理解就是以父类的虚函数作为公共接口即使子类中虚函数是私有的也可以通过父类的虚函数进行访问执行已检验可实现如果以值传递的方式那么只是传递了一个副本编译器会认为是父类的对象不会进行多态直接执行父类的函数子类继承父类子类中必然有虚函数调用虚函数需要通过虚函数表指针父子类的虚函数表指针指向的虚函数表不同但指针名相同当传入的是子类的时候会以子类的虚函数表指针为准找到执行子类虚函数指针名是否相同还没有在网上找到答案但是我通过开发人员命令提示符中是相同的纯虚函数和抽象类在多态中通常父类中虚函数的实现是毫无意义的主要都是调用子类重写的内容因此可以将虚函数改为纯虚函数纯虚函数语法返回值类型函数名参数列表当类中有了纯虚函数这个类也称为抽象类抽象类特点无法实例化对象子类必须重写抽象类中的纯虚函数否则也属于抽象类示例在多态中通常父类中虚函数是毫无意义的主要作用是调用子类重写的内容因此可以将虚函数该为纯虚函数语法返回值类型函数名形参列表当类中有了纯虚函数这个类也叫抽象类特点无法实例化对象子类必须重写抽象类中的纯虚函数否则也叫抽象类当类中有了纯虚函数这个类也叫抽象类无法实例化对象无法实例化对象子类必须重写纯虚函数否则是抽象类无法实例化对象虚析构和纯虚析构多态使用时如果子类中有属性开辟到堆区那么父类指针在释放时无法调用到子类的析构代码解决方式将父类中的析构函数改为虚析构或者纯虚析构虚析构和纯虚析构共性可以解决父类指针释放子类对象都需要有具体的函数实现虚析构和纯虚析构区别如果是纯虚析构该类属于抽象类无法实例化对象类内声明类外实现虚析构语法类名纯虚析构语法类名类名类名示例多态在使用的时候如果有子类中有属性开辟到堆区那么父类指针在释放的时无法调用到子类的析构代码通过将父类中的析构函数改为虚析构或者纯虚析构可以解决虚析构和纯虚析构的共性可以解决父类指针释放子类对象都需要有具体的函数实现区别如果是纯虚析构该类属于抽象类无法实例化对象语法纯虚析构类内声明类外实现类名虚析构类名父类的构造函数调用虚析构父类的析构函数调用纯虚析构类内声明类外实现有了父类的析构函数调用子类的构造函数调用小狗在说话子类的析构函数调用卧槽因为开辟在堆区如果不销毁的析构函数就一直不会执行因为一直存在那么父类也会存在总结虚析构或纯虚析构就是用来解决通过父类指针释放子类对象如果子类中没有堆区数据可以不写为虚析构或纯虚析构拥有纯虚析构函数的类也属于抽象类如果子类在堆区中不销毁那么因为子类而出现的父类也不会销毁案例多态有个案例在案例练习区计算器制作饮品组装电脑文件操作程序运行时产生的数据都属于临时数据程序一旦运行结束都会被释放通过文件可以将数据持久化中对文件操作需要包含头文件文件类型分为两种文本文件文件以文本的码形式存储在计算机中二进制文件文件以文本的二进制形式存储在计算机中用户一般不能直接读懂它们操作文件的三大类写操作读操作读写操作文本文件写文件写文件步骤如下包含头文件创建流对象打开文件文件路径打开方式写数据写入的数据关闭文件文件打开方式打开方式解释为读文件而打开文件为写文件而打开文件初始位置文件尾追加方式写文件如果文件存在先删除再创建二进制方式注意文件打开方式可以配合使用利用操作符例如用二进制方式写文件程序运行时产生的数据都属于临时数据程序一旦运行结束都会释放通过文件可以将数据持久化中对文件操作需要包含头文件文件类型包含两种文本文件文件以文本的码形式储存在计算机中二进制文件文件以文本的二进制形式储存在计算机中用户一般看不懂操作写操作读操作读写操作写文件包含头文件创建流对象指定打开方式如果不指定路径文件就会保存在源文件路径下写内容姓名张三性别男电话关闭文件程序运行时产生的数据都属于临时数据程序一旦运行结束都会释放通过文件可以将数据持久化中对文件操作需要包含头文件文件类型包含两种文本文件文件以文本的码形式储存在计算机中二进制文件文件以文本的二进制形式储存在计算机中用户一般看不懂操作写操作读操作读写操作写文件包含头文件创建流对象指定打开方式如果不指定路径文件就会保存在源文件路径下写内容姓名张三性别男电话关闭文件总结文件操作必须包含头文件读文件可以利用或者类打开文件时候需要指定操作文件的路径以及打开方式利用可以向文件中写数据操作完毕要关闭文件读文件读文件与写文件步骤相似但是读取方式相对于比较多读文件步骤如下包含头文件创建流对象打开文件并判断文件是否打开成功文件路径打开方式读数据四种方式读取关闭文件示例包含头文件创建流对象打开文件并判断文件是否打开成功是一个布尔函数打开成功就会返回真文件打开失败读数据第一种第二种是整行读取数组地址数组内存第三种全局的函数基础的输入流对象字符串第四种效率低一个一个读只要没有读到尾就一直读关闭文件总结读文件可以利用或者类利用函数可以判断文件是否打开成功关闭文件二进制文件以二进制的方式对文件进行读写操作打开方式要指定为写文件二进制方式写文件主要利用流对象调用成员函数函数原型参数解释字符指针指向内存中一段存储空间是读写的字节数示例包含头文件创造流对象也可以写在这里因为有构造函数直接打开文件打开文件写文件张三传入类型的地址类的内存关闭文件总结文件输出流对象可以通过函数以二进制方式写数据读文件二进制方式读文件主要利用流对象调用成员函数函数原型参数解释字符指针指向内存中一段存储空间是读写的字节数示例包含头文件创造流对象打开文件并判断是否打开文件打开失败读对象用来接收指针接收因为方便字节替换每次指针就是向后移动一个类型的字节关闭文件文件输入流对象可以通过函数以二进制方式读数据核心篇完结撒花',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-03 22:20:46',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2024/12/19/6763fb8953276.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">小楼夜听雨</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=13091820019&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url">笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-05-10T11:27:31.000Z" title="发表于 2024-05-10 19:27:31">2024-05-10</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-01-03T14:20:46.271Z" title="更新于 2025-01-03 22:20:46">2025-01-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">21.8k</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为茂名"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>茂名</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2024/12/29/677157b8efbea.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><header><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url">笔记</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><h1 id="CrawlerTitle" itemprop="name headline">C++面向对象编程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小楼夜听雨</span><time itemprop="dateCreated datePublished" datetime="2024-05-10T11:27:31.000Z" title="发表于 2024-05-10 19:27:31">2024-05-10</time><time itemprop="dateCreated datePublished" datetime="2025-01-03T14:20:46.271Z" title="更新于 2025-01-03 22:20:46">2025-01-03</time></header><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p> 在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p> <strong>代码区：</strong></p>
<p> 存放 CPU 执行的机器指令</p>
<p> 代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p> 代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p> <strong>全局区：</strong></p>
<p> 全局变量和静态变量存放在此.</p>
<p> 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p> 该区域的数据在程序结束后由操作系统释放.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量：不在函数体中定义的变量</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的全局变量(全局常量)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//全局区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局变量、静态变量，常量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量：在函数体内定义的变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量c的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量d的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;d &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量：在普通变量的前面加 static</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量e的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;e &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量f的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//常量： 字符串常量；const修饰的常量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的局部变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> h = <span class="number">0</span>;<span class="comment">//（局部常量）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;123456&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量的地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;h &lt;&lt; endl;<span class="comment">//不在全局区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//总结：在局部的和局部常量都不在全局区，全局变量，静态变量，字符串常量，全局常量在全局区</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/61dd266b2ab3f51d917114b9.png"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量 和 字符串常量</li>
</ul>
<h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p> <strong>栈区：</strong></p>
<p> 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p> 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>堆区：</strong></p>
<p> 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p> 在C++中主要利用new在堆区开辟内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">(<span class="type">int</span> b)</span><span class="comment">//形参数据也会放在栈区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量	存放在栈区，栈区的数据在函数执行完后自动释放</span></span><br><span class="line">	<span class="keyword">return</span> &amp;a;<span class="comment">//返回局部变量地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟堆区</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//利用new关键字，可以将数据开辟到堆区</span></span><br><span class="line">	<span class="comment">//指针p是局部变量，而指针保存的数据是放在堆区</span></span><br><span class="line">	<span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//程序运行后：会划分栈区和堆区</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；</span></span><br><span class="line">	<span class="comment">//注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放(野指针警告)</span></span><br><span class="line">	<span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>(b);		</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;		<span class="comment">//第一次可以打印正确的数字，是因为编译器做了保留</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;		<span class="comment">//第二次这个数据就不再保留了(vs2022在64位的情况下对返回值进行了优化，进行了保留)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//堆区	由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</span></span><br><span class="line">	<span class="comment">//在C++中主要利用new在堆区开辟内存</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* p1 = <span class="built_in">func1</span>();<span class="comment">//指针已经捕获了在堆区的地址，所以在栈区的指针变量即使被释放也不影响</span></span><br><span class="line">	cout &lt;&lt; *p1 &lt;&lt; endl;	</span><br><span class="line">	cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="new操作符和在堆区开辟数组"><a href="#new操作符和在堆区开辟数组" class="headerlink" title="new操作符和在堆区开辟数组"></a>new操作符和在堆区开辟数组</h3><p> C++中利用new操作符在堆区开辟数据</p>
<p> 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <code>delete</code></p>
<p> 释放堆区数组的时候，要加[]	<code>delete[]arr;</code></p>
<p> 语法：<code> new 数据类型</code></p>
<p> 利用new创建的数据，会返回该数据对应的类型的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func10</span><span class="params">()</span><span class="comment">//利用new操作符在堆区开辟数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5201314</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func10</span>();</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//堆区由程序员分配释放,可以手动释放，使用操作符：delete</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl;	如果这个时再访问就是非法操作（野指针）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆区利用new开辟数组：利用[]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//10代表10个元素,返回的是数组的首地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; a++) &#123; arr[a] = a+<span class="number">100</span>; &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; a++) &#123; cout &lt;&lt; arr[a]&lt;&lt;endl; &#125;</span><br><span class="line">	<span class="comment">//释放堆区数组的时候，要加[]</span></span><br><span class="line">	<span class="keyword">delete</span>[]arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//C++中利用new操作符在堆区开辟数据</span></span><br><span class="line">	<span class="comment">//可以手动释放，使用操作符：delete</span></span><br><span class="line">	<span class="comment">//利用new创建数据，会返回该数据对应的类型的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//引用：给变量起别名，别名和原名都代表同一个内存空间</span></span><br><span class="line">	<span class="comment">//语法：数据类型 &amp;别名 =原名</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; b = a;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//引用必须初始化	</span></span><br><span class="line">	<span class="comment">//引用在初始化后，不可以改变,可以赋值	（一旦代表一段内存空间后就不可更改）</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;		<span class="comment">//int&amp; b;是错误的</span></span><br><span class="line">	<span class="type">int</span>&amp; b = a;		<span class="comment">//int&amp; b = c;是错误的</span></span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引用做函数参数-引用传递"><a href="#引用做函数参数-引用传递" class="headerlink" title="引用做函数参数(引用传递)"></a>引用做函数参数(引用传递)</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span><span class="comment">//引用传递（引用做形参的时候不用初始化）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//函数传参时，可以利用引用的技术让形参修饰实参</span></span><br><span class="line">	<span class="comment">//可以简化指针修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">A</span>(a, b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</strong></p>
<h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的（该函数就是引向返回值的地址，函数名本身就是别名？）</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用做函数返回值</span></span><br><span class="line"><span class="comment">//1.不要返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//局部变量存放在栈区</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的调用可以作为左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//静态变量，存放在全局区，全局区上的数据在程序结束后系统释放(生命周期加长)</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;	<span class="comment">//第一次可以打印正确的数字，是因为编译器做了保留</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test03</span>();<span class="comment">//ref02已经是test03的别名</span></span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test03</span>() = <span class="number">1000</span>;<span class="comment">//如果函数的返回值是引用，这个函数调用可以作为左值</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ab</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span><span class="comment">//常量引用，引用可修改，常量不可修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//a=1000;不可修改，防止误操作</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//常量引用</span></span><br><span class="line">	<span class="comment">//使用场景：用来修饰形参，防止误操作</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int &amp;a = 10;引用必须引向一块合法内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//加上const之后，编译器将代码修改，int temp =10; const int &amp; ref =temp;	(temp指的是一块临时空间)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref=10；const之后，改为只读，不可修改</span></span><br><span class="line">	<span class="built_in">ab</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型 函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的默认参数(如果没有传入参数，则使用默认使用形参的默认值)</span></span><br><span class="line"><span class="comment">//语法 ：返回值类型 函数名 （形参 = 默认值）&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">20</span>, <span class="type">int</span> c=<span class="number">30</span>)</span><span class="comment">//注意：如果某个位置已经有了默认值，那么从这个位置往后，从左到右都必须有默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：如果某个位置已经有了默认值，那么从这个位置往后，从左到右都必须有默认值</span></span><br><span class="line"><span class="comment">//int func1(int a, int b = 20, int c)//会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果函数声明有默认参数，函数实现就不能有默认参数（会重复定义默认参数，声明和实现只能一个有默认参数）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="comment">//int func2(int a=10, int b)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果某个位置已经有了默认值，那么从这个位置往后，从左到右都必须有默认值</strong></p>
<p><strong>注意：如果函数声明有默认参数，函数实现就不能有默认参数（会重复定义默认参数，声明和实现只能一个有默认参数）</strong></p>
<h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占位参数</span></span><br><span class="line"><span class="comment">//返回值类型 函数名 (数据类型)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目前阶段的占位参数我们还用不到，后面函数重载会用到</span></span><br><span class="line"><span class="comment">//占位参数也可以有默认参数《更没有用了(滑稽)》</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>,<span class="type">int</span> =<span class="number">10</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>-》根据不同的调用参数，会自动使用对应的函数</li>
</ul>
<p><strong>注意:</strong> 函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载</span></span><br><span class="line"><span class="comment">//可以使函数名相同，提高复用性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载的满足条件</span></span><br><span class="line"><span class="comment">// 1.同一个作用域下（全局或者其他）</span></span><br><span class="line"><span class="comment">// 2.函数名称相同</span></span><br><span class="line"><span class="comment">// 3.函数的参数类型不同，或者个数不同，或者顺序不同	-》根据不同的调用参数，会自动使用对应的函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;funf5的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;funf5(int a)的调用2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;funf5(double a)的调用3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;funf5(double a,int b)的调用3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">( <span class="type">int</span> b,<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;funf5( int b,double a)的调用3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：函数的返回值类型不可以作为函数重载的条件(因为如果参数相同，就无法区分调用哪个函数内容，因为返回值可以不接收输出)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;cout &lt;&lt; <span class="string">&quot;funf5的调用&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="comment">//int A()&#123;cout &lt;&lt; &quot;funf5的调用&quot; &lt;&lt; endl;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func5</span>();</span><br><span class="line">	<span class="built_in">func5</span>(<span class="number">10</span>);<span class="comment">//根据不同的调用参数，会自动使用对应的函数</span></span><br><span class="line">	<span class="built_in">func5</span>(<span class="number">10.0</span>);</span><br><span class="line">	<span class="built_in">func5</span>(<span class="number">10.0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">func5</span>(<span class="number">1</span>,<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：函数的返回值类型不可以作为函数重载的条件(因为如果参数相同，就无法区分调用哪个函数内容，因为返回值可以不接收输出)</strong></p>
<h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1.引用作为重载条件</span></span><br><span class="line"><span class="comment">//void func6(int a)&#123;cout &lt;&lt; &quot;func6(int a)的引用&quot; &lt;&lt; endl;&#125;有引用这个类型的时候不能定义相同类型的形参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func6</span><span class="params">(<span class="type">int</span>&amp; a)</span><span class="comment">//int&amp; a =10;不合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func6(int&amp; a)的引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func6</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span><span class="comment">//a的数据被传进来后只能读不能写</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func6(const int&amp; a)的引用&quot;</span> &lt;&lt; endl;<span class="comment">//const int&amp; a =10;合法，会创造一个临时空间存放数据，并引向临时空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数重载碰到默认参数（会出现二义性（歧义））语法本身没有问题，不调用就不会报错，写重载的时候尽量避免写默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func7</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func(int a)的引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">\</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func7</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func(int a,int b=10)的引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func6</span>(a);<span class="comment">//a的值是变量（可读可写），所以会被int&amp; a的函数调用</span></span><br><span class="line">	<span class="built_in">func6</span>(<span class="number">10</span>);<span class="comment">//常量不可被修改，所以会被const int&amp; a的函数调用,int&amp; a只能引向合法的内存地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func7(a/10),两个都可以传入参数，编译器：我机傻了（滑稽）</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">func7</span>(a,<span class="number">10</span>);<span class="comment">//参数完整的时候可以运行</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：有引用这个类型的形参的时候不能定义相同类型的形参</strong></p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性为：封装、继承、多态</p>
<p>C++认为万事万物都皆为对象，对象上有其属性和行为</p>
<p>属性和行为,统一称为成员<br>属性	也叫	成员属性 成员变量<br>行为	也叫	成员函数 成员方法</p>
<p><strong>例如：</strong></p>
<p> 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p> 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p> 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><h5 id="封装意义一：设计类"><a href="#封装意义一：设计类" class="headerlink" title="封装意义一：设计类"></a>封装意义一：设计类</h5><p> 在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="comment">//c++面向对象的三大特性为：封装，继承，多态</span></span><br><span class="line">	<span class="comment">// c++认为万事万物都皆为对象，对象上有其属性和行为,统一称为成员</span></span><br><span class="line">	<span class="comment">//具有相同性质的对象，我们可以抽象称为类</span></span><br><span class="line">	<span class="comment">//属性和行为,统一称为成员</span></span><br><span class="line">	<span class="comment">// 属性	也叫	成员属性 成员变量</span></span><br><span class="line">	<span class="comment">// 行为	也叫	成员函数 成员方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//访问权限：（公共权限）</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//属性 （半径）:变量</span></span><br><span class="line">		<span class="type">int</span> r;</span><br><span class="line">		<span class="comment">//行为：（获取圆的周长）：函数</span></span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">ZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//封装的意义</span></span><br><span class="line">	<span class="comment">// 将属性和行为作为一个整体，表现生活中的事物</span></span><br><span class="line">	<span class="comment">// 将属性和行为加以权限控制</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将属性和行为作为一个整体，表现生活中的事物</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//在设计类的时候，属性和行为写在一起，表现事物</span></span><br><span class="line">	<span class="comment">//语法:class 类名&#123;访问权限：属性 / 行为&#125;；</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类 创建具体的圆（对象）(实例化)</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	<span class="comment">//给圆的对象 的属性进行赋值</span></span><br><span class="line">	c1.r = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.<span class="built_in">ZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将属性和行为加以权限控制</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//public	公共权限	成员类内外都可访问</span></span><br><span class="line">	<span class="comment">//protected	保护权限	成员类内可以访问，类外不可访问	在继承中，子可以访问父中的保护内容</span></span><br><span class="line">	<span class="comment">//private	私有权限	成员类内可以访问，类外不可访问	在继承中，子不可以访问父中的私有内容</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>一般情况下，我们把类的声明部分写在自定义的头文件上，把类的实现部分写在一个单独的源文件（.cpp）内，以简化主函数源文件的代码数量，详细内容看案例练习部分</strong></p>
<h5 id="封装意义二：封装的权限控制"><a href="#封装意义二：封装的权限控制" class="headerlink" title="封装意义二：封装的权限控制"></a>封装意义二：封装的权限控制</h5><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public 公共权限			成员类内外都可访问</li>
<li>protected 保护权限     成员类内可以访问，类外不可访问	在继承中，子可以访问父中的保护内容</li>
<li>private 私有权限          成员类内可以访问，类外不可访问	在继承中，子不可以访问父中的私有内容</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//公共权限	</span></span><br><span class="line">	string name;	<span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//保护权限</span></span><br><span class="line">	<span class="type">int</span> car_id;		<span class="comment">//车的密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="comment">//私有权限		//银行卡密码</span></span><br><span class="line">	<span class="type">int</span> password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//如果函数不是公共权限，也不可访问</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//在类内，所以权限都可以访问</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		car_id = <span class="number">123456</span>;</span><br><span class="line">		password = <span class="number">123654</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将属性和行为加以权限控制</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//public	公共权限	成员类内外都可访问</span></span><br><span class="line">	<span class="comment">//protected	保护权限	成员类内可以访问，类外不可访问	在继承中，子可以访问父中的保护内容</span></span><br><span class="line">	<span class="comment">//private	私有权限	成员类内可以访问，类外不可访问	在继承中，子不可以访问父中的私有内容</span></span><br><span class="line"></span><br><span class="line">	parson p1;</span><br><span class="line">	p1.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	<span class="comment">//p1.car_id = 123456;不可访问</span></span><br><span class="line">	<span class="comment">//p1.password = 123654;不可访问</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//默认权限为私有</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在C++中，struct和class的唯一区别就在于 默认访问权限不同</span></span><br><span class="line">	<span class="comment">//struct	默认权限为公共</span></span><br><span class="line">	<span class="comment">//class		默认权限为私有</span></span><br><span class="line">	C1 c1;</span><br><span class="line">	<span class="comment">//c1.a = 100;默认权限所有不可访问</span></span><br><span class="line"></span><br><span class="line">	B1 b1;</span><br><span class="line">	b1.a = <span class="number">100</span>;<span class="comment">//默认权限公共，可以访问</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//写入姓名的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(string name1)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		name = name1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取姓名的函数</span></span><br><span class="line">	<span class="function">string <span class="title">getname</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取年龄的函数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入偶像的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setidol</span><span class="params">(string idol2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		idol = idol2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入年龄（0~150）</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setage</span><span class="params">(<span class="type">int</span> age1)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age1 &lt; <span class="number">0</span> || age1&gt;<span class="number">150</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入有误&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;<span class="comment">//姓名，可读可写</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age=<span class="number">18</span>;<span class="comment">//年龄，只读,可以默认,如果年龄可写，则要限定范围（要检测数据有效性）</span></span><br><span class="line"></span><br><span class="line">	string idol;<span class="comment">//偶像，只写</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	p1.<span class="built_in">setname</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	p1.<span class="built_in">setage</span>(<span class="number">156</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p> 一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p> 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理</span></span><br><span class="line">	<span class="comment">//1.构造函数  进行初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//1.构造函数</span></span><br><span class="line">	<span class="comment">//没有返回值，不用写void</span></span><br><span class="line">	<span class="comment">// 函数名 与类名相同</span></span><br><span class="line">	<span class="comment">// 构造函数可以有参数  可以发生重载</span></span><br><span class="line">	<span class="comment">// 创造对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person构造函数的调用1111&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.析构函数 进行清理的操作</span></span><br><span class="line">	<span class="comment">// 没有返回值，不写void</span></span><br><span class="line">	<span class="comment">// 函数名和类名相同，在名称前面加~</span></span><br><span class="line">	<span class="comment">// 没有参数，不可以发生重载</span></span><br><span class="line">	<span class="comment">// 对象在销毁前 会自动调用析构函数，而且只会调用一次</span></span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;<span class="comment">//在栈区的数据，ABC在执行完之后，释放这个对象</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main00</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ABC</span>();</span><br><span class="line">	person p2;<span class="comment">//在程序结束运行后会执行析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p>
<p> 按参数分为： 有参构造和无参构造</p>
<p> 按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p> 括号法</p>
<p> 显示法</p>
<p> 隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的分类和调用</span></span><br><span class="line"><span class="comment">//1.分类</span></span><br><span class="line"><span class="comment">//	按照参数分类	无参构造(默认构造)和有参构造</span></span><br><span class="line"><span class="comment">//	按照类型分类	普通构造	拷贝构造</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;cout &lt;&lt; <span class="string">&quot;person无参构造函数的调用&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">const</span> person&amp; p)<span class="comment">//如果值传递，则会创建一个副本，将对象的属性复制过来，当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将传入的人身上的所有属性，拷贝的我（当前对象）身上</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		age = p.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person析构函数的调用&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 1.括号法</span></span><br><span class="line">		person p;<span class="comment">//默认构造函数调用</span></span><br><span class="line">		<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数调用</span></span><br><span class="line">		<span class="function">person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">//拷贝构造函数的调用</span></span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p3的年龄：&quot;</span> &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注意：</span></span><br><span class="line">		<span class="comment">// 默认构造函数调用不要加小括号</span></span><br><span class="line">		<span class="comment">// person p ():会被认为是一个声明</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2.显示法</span></span><br><span class="line">		person p1;</span><br><span class="line">		person p4 = <span class="built_in">person</span>(<span class="number">10</span>);</span><br><span class="line">		person p5 = <span class="built_in">person</span>(p2);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">person</span>(<span class="number">10</span>);<span class="comment">//匿名对象   特点：当前行执行结束后，系统会立刻回收匿名对象</span></span><br><span class="line">		<span class="comment">//不要利用拷贝构造函数初始化匿名对象(编译器会认为person（p6）==person p6;对象声明)</span></span><br><span class="line">		<span class="built_in">person</span>(p6);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;aaa&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.隐式转化法</span></span><br><span class="line">		person p7 = <span class="number">10</span>; <span class="comment">//相当于写了person p7=person (10);有参构造</span></span><br><span class="line">		person p8 = p7;<span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>拷贝函数必须是引用传递，否则会无限递归；</p>
<h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使用时机</span></span><br><span class="line"><span class="comment">// 1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="comment">// 2.值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">// 3.值的方式返回局部对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">person1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person无参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person1</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person1</span>(<span class="type">const</span> person1&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">person1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person1 <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">person1 <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.值传递的方式给函数（形参）参数传值(值传递会调用拷贝函数进行创建副本拷贝)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaa</span><span class="params">(person1 a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person1 p3;</span><br><span class="line">	<span class="built_in">aaa</span>(p3);<span class="comment">//将p3的属性值传递给形参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.值的方式返回局部对象</span></span><br><span class="line"><span class="function">person1 <span class="title">bbb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person1 <span class="title">p5</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p5的年龄：&quot;</span> &lt;&lt; p5.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;p5;</span><br><span class="line">	 <span class="comment">//return p5;不会调用拷贝构造函数，返回本身，所以地址一样</span></span><br><span class="line">	 <span class="keyword">return</span> <span class="built_in">person1</span> (p5);<span class="comment">//会调用拷贝构造函数，返回p4，地址不一样</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person1 p4 = <span class="built_in">bbb</span>();</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4的年龄：&quot;</span> &lt;&lt; p4.age &lt;&lt; endl;</span><br><span class="line">	p4.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main004</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的调用规则</span></span><br><span class="line"><span class="comment">//1.创建一个类，c++编译器会给每个类都至少添加3个函数</span></span><br><span class="line"><span class="comment">// 默认构造（空实现）</span></span><br><span class="line"><span class="comment">// 析构函数（空实现）</span></span><br><span class="line"><span class="comment">// 拷贝构造 (值拷贝)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.如果我们写了有参构造函数，编译器就不再提供默认构造，依然通过拷贝构造</span></span><br><span class="line"><span class="comment">// 3.如果我们写了拷贝构造函数，编译器就不再提供构造函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*person2()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;person构造函数的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*person2(int a)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		age = a;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;person有参构造函数的调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">person2</span>(<span class="type">const</span> person2&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">person2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test001</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*person2 p;</span></span><br><span class="line"><span class="comment">	p.age = 18;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	person2 p2(p);//默认的值拷贝</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;p2的年龄：&quot; &lt;&lt; p2.age &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test002</span><span class="params">()</span><span class="comment">// 2.如果我们写了有参构造函数，编译器就不再提供默认构造，依然通过拷贝构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//person2 p;</span></span><br><span class="line">	<span class="comment">//person2 p(20);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//person2 p2(p);//默认的值拷贝</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p2的年龄：&quot; &lt;&lt; p2.age &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main002</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test001</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作，浅拷贝的问题就是堆区的重复释放</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝和浅拷贝</span></span><br><span class="line"><span class="comment">//浅拷贝的问题就是堆区的重复释放</span></span><br><span class="line"><span class="comment">//深拷贝就是自己写一个拷贝构造函数，拷贝的时候创建一个新的堆区，防止将对象的指针地址拷贝过来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person3</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">person3</span>(<span class="type">int</span> age1,<span class="type">int</span> heighit1)</span><br><span class="line">	&#123;</span><br><span class="line">		age = age1;</span><br><span class="line">		height = <span class="keyword">new</span> <span class="built_in">int</span>(heighit1);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">person3</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//析构代码	将堆区开辟的数据做释放操作</span></span><br><span class="line">		<span class="keyword">if</span> (height != <span class="literal">NULL</span>)<span class="comment">//如果身高的指针不等于空</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> height;<span class="comment">//释放堆区的数据</span></span><br><span class="line">			height = <span class="literal">NULL</span>;<span class="comment">//防止野指针的出现</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person3</span>(<span class="type">const</span> person3&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.height);<span class="comment">//将对象的指针解引用的值放进堆区，并将堆区地址赋给当前的指针</span></span><br><span class="line">		age = p.age;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span>* height;<span class="comment">//如果是系统默认的浅拷贝，会把指针地址也拷贝过去，但是当一个类的这个指针被释放之后，再次释放就是非法操作，报错</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sest003</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person3 <span class="title">p1</span><span class="params">(<span class="number">20</span>,<span class="number">160</span>)</span></span>;<span class="comment">//栈区规则：先进后出，p1进，p2进，p2出，p1出</span></span><br><span class="line">	<span class="function">person3 <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的身高：&quot;</span> &lt;&lt; *p2.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main005</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sest003</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表初始化属性</span></span><br><span class="line"><span class="comment">//类名(有无参):属性(初始值)，属性(初始值)...&#123;	实现	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传统初始化</span></span><br><span class="line">	<span class="comment">/*person4(int a, int b, int c)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		a1 = a;</span></span><br><span class="line"><span class="comment">		b1 = b;</span></span><br><span class="line"><span class="comment">		c1 = c;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表初始化属性</span></span><br><span class="line">	<span class="built_in">person4</span>() :<span class="built_in">a1</span>(<span class="number">10</span>), <span class="built_in">b1</span>(<span class="number">20</span>), <span class="built_in">c1</span>(<span class="number">30</span>)<span class="comment">//是一种无参构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//实现</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">person4</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">a1</span>(a), <span class="built_in">b1</span>(b), <span class="built_in">c1</span>(c)<span class="comment">//有参构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a1;</span><br><span class="line">	<span class="type">int</span> b1;</span><br><span class="line">	<span class="type">int</span> c1;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sest005</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person4 p;</span><br><span class="line">	<span class="function">person4 <span class="title">p2</span><span class="params">(<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p.a1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.c1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.a1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.c1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main006</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sest005</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	类对象作为类成员</span></span><br><span class="line"><span class="comment">//当其他类对象作为本类的成员，在构造的时候先构造其他类对象，再构造自身（先有零件，再有本体）</span></span><br><span class="line"><span class="comment">//析构函数按照栈区规则，先进后出（先析构本体，再析构零件)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		name1 = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;手机的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string  name1;</span><br><span class="line">	~<span class="built_in">phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;手机析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person5</span>(string name1, string name2):<span class="built_in">name</span>(name1),<span class="built_in">sj</span>(name2)<span class="comment">//phone js=name2	隐式转化法phone js =phone(name2)</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;人的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">person5</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;人析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//姓名</span></span><br><span class="line">	string name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 手机</span></span><br><span class="line">	phone sj;</span><br><span class="line">	 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sest006</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person5 <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果15&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p1.name &lt;&lt; p1.sj.name1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main007</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sest006</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量（末影箱里面的物品的数据）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 所以对象都共享同一份数据（相当于末影箱里的物品的数据）</span></span><br><span class="line">	<span class="comment">// 编译阶段就分配了内存</span></span><br><span class="line">	<span class="comment">// 类内声明，类外初始化操作</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> phone::a=<span class="number">100</span>;<span class="comment">//类外初始化操作</span></span><br><span class="line"><span class="type">int</span> phone::b=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sest007</span><span class="params">()</span><span class="comment">// 所以对象都共享同一份数据（相当于末影箱）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	phone p1;</span><br><span class="line">	cout &lt;&lt; p1.a &lt;&lt; endl;</span><br><span class="line">	phone p2;</span><br><span class="line">	p2.a = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; p1.a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sest008</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量 不属于某个对象上，所有对象都共享同一份数据</span></span><br><span class="line">	<span class="comment">//因此静态成员变量有两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.通过对象进行访问</span></span><br><span class="line">	phone p;</span><br><span class="line">	cout &lt;&lt; p.a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.通过类名进行访问</span></span><br><span class="line">	cout &lt;&lt; phone::a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; phone::b &lt;&lt; endl;错误，没有访问权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main008</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sest008</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong>静态成员函数（末影箱，只能访问末影箱物品的数据，不能访问箱子的数据）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//静态成员函数	（相当于末影箱，只能访问末影箱的数据，不能访问箱子的数据）</span></span><br><span class="line"><span class="comment">// 所以对象共享一个函数</span></span><br><span class="line"><span class="comment">// 静态成员函数只能访问静态成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c = <span class="number">300</span>;<span class="comment">// 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//e=300；静态成员函数不能访问非静态成员变量（因为静态函数是所以对象共享的，如果一个对象调用的时候，函数不知道访问哪个对象的非静态变量）</span></span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;静态函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> e;<span class="comment">//非静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;静态函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> phone::c = <span class="number">100</span>;<span class="comment">//类外初始化操作</span></span><br><span class="line"><span class="type">int</span> phone::d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sest009</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//访问方法</span></span><br><span class="line">	<span class="comment">//1. 通过对象访问</span></span><br><span class="line">	phone p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//p1.func2();报错//静态成员函数也是有访问权限的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 通过类名访问</span></span><br><span class="line">	phone::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sest009</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开储存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员变量 不属于类的对象上（只有一份）</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数 不属于类的对象上（只有一份）</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//静态成员函数 不属于类的对象上（只有一份）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	<span class="comment">//空对象占用的内存空间为：1</span></span><br><span class="line">	<span class="comment">//C++编译器会给每个空对象也分配一个字节的空间，是为了区分空对象占内存的位置</span></span><br><span class="line">	<span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;空对象的内存多大：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;有int的对象的内存多大：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>通过上面我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针指向被调用成员函数所属的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.解决名称冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.返回对象本身用*this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//1.解决名称冲突</span></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;<span class="comment">//指向 被调用成员函数(person(int age) 所属的对象p1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function">person&amp; <span class="title">add</span><span class="params">(person &amp;p)</span><span class="comment">//以引用的方式返回，如果不用引用就是值返回就是拷贝p3本体，实际上返回的是副本person1（如果还返回就是person2，是副本的副本），所以后面的.add（）就和p3没有关系了</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age +=p.age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//this指向p3的指针 	*this表示p3的本体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄：&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链式编程思想</span></span><br><span class="line">	p3.<span class="built_in">add</span>(p2).<span class="built_in">add</span>(p2).<span class="built_in">add</span>(p2);<span class="comment">//add函数返回p3的本体，所以可以增加.进行操作</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄：&quot;</span> &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这个类的名称叫 person&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span>  <span class="title">ShowAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//会报错，因为this指针是空指针，解决方法</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这个人的年龄：&quot;</span> &lt;&lt; age &lt;&lt; endl;<span class="comment">//age前面默认有一个this-&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person* p = <span class="literal">NULL</span>;<span class="comment">//空指针</span></span><br><span class="line"></span><br><span class="line">	p-&gt;<span class="built_in">ShowAge</span>();</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test4</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="comment">//在成员函数括号后面加const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//常函数</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//this指针的本质是指针常量，指向不可修改 person * const this</span></span><br><span class="line">	<span class="comment">//this = NULL;是错误的</span></span><br><span class="line">	<span class="comment">//在成员函数后面加const，修饰的是this指针，让指针指向的值也不可修改</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span><span class="type">const</span><span class="comment">//const person * const this</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		age1 = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//this-&gt;age = 100;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> age1;<span class="comment">//特殊变量，即使在常函数中，也可以修改这个值，在前面加关键字mutable</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showage2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="comment">//在对象前加上const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> person p;<span class="comment">//常对象的正常属性不允许修改</span></span><br><span class="line">	<span class="comment">//p.age = 100;</span></span><br><span class="line">	p.age1 = <span class="number">500</span>; <span class="comment">//加了mutable的特殊变量在常对象下也可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象只能调用常函数</span></span><br><span class="line">	<span class="comment">//p.showage2()	因为普通成员函数里面是可以修改属性的值的，所以不能调用普通成员函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test6</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为 friend</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数做友元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buiding</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//friend +函数声明 ：全局函数goodgay是buiding类的好朋友，可以访问私有成员</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay</span><span class="params">(buiding* buiding)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">buiding</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_sittingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		m_bedroom=<span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_sittingroom;<span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_bedroom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数（好基友）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay</span><span class="params">(buiding *buiding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友的全局函数正在访问：&quot;</span> &lt;&lt; buiding-&gt;m_sittingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友的全局函数正在访问：&quot;</span> &lt;&lt; buiding-&gt;m_bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	buiding b1;</span><br><span class="line">	<span class="built_in">goodgay</span>(&amp;b1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main00</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类做友元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buiding</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodgay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">goodgay</span>();<span class="comment">//在堆区开辟一个建筑物对象，用buiding1接收</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数通过访问buiding1指针访问在堆区的建筑物对象</span></span><br><span class="line">	</span><br><span class="line">	buiding * buiding1;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buiding</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//friend +类声明 ：goodgay类是buiding类的好朋友，可以访问私有成员</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodgay</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">buiding</span>();<span class="comment">//将客厅和卧室初始化给下面的变量</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_sittingroom;<span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_bedroom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外写成员函数（注意要类内声明）</span></span><br><span class="line">buiding::<span class="built_in">buiding</span>()</span><br><span class="line">&#123;</span><br><span class="line">		m_sittingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">goodgay::<span class="built_in">goodgay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	buiding1 = <span class="keyword">new</span> buiding;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;好基友的类正在访问：&quot;</span> &lt;&lt;buiding1-&gt;m_sittingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友的类正在访问：&quot;</span> &lt;&lt; buiding1-&gt;m_bedroom &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodgay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做友元（让参观函数1访问建筑物类的内容）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buiding</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodgay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">goodgay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让参观函数1访问建筑物类的内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//不让参观函数2访问</span></span><br><span class="line">	buiding* buiding1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buiding</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//friend +函数声明和作用域 ：goodgay类下的visit1成员函数是buiding类的好朋友，可以访问私有成员</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">buiding</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_sittingroom;<span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_bedroom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外写成员函数（注意要类内声明）</span></span><br><span class="line">buiding::<span class="built_in">buiding</span>()</span><br><span class="line">&#123;</span><br><span class="line">	m_sittingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">goodgay::<span class="built_in">goodgay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	buiding1 = <span class="keyword">new</span> buiding;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span><span class="comment">//必须定义在friend后面，否则无法访问（所以最好声明在类内，定义在类外）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友的成员函数正在访问：&quot;</span> &lt;&lt; buiding1-&gt;m_sittingroom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友的成员函数正在访问：&quot;</span> &lt;&lt; buiding1-&gt;m_bedroom &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友的成员函数2正在访问：&quot;</span> &lt;&lt; buiding1-&gt;m_sittingroom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友的成员函数正在访问：&quot; &lt;&lt; buiding1-&gt;m_bedroom &lt;&lt; endl;报错，没有权限访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodgay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line">	gg.<span class="built_in">visit2</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加号运算符重载	可以让自定义的数据类型相加	operator+</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1.成员函数重载+号</span></span><br><span class="line"><span class="comment">//					</span></span><br><span class="line"><span class="comment">// 2.全局函数重载+号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数重载+号</span></span><br><span class="line">	<span class="comment">/*person operator+(person&amp; p)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		person temp;</span></span><br><span class="line"><span class="comment">		temp.m_a = this-&gt;m_a + p.m_a;</span></span><br><span class="line"><span class="comment">		temp.m_b = this-&gt;m_b + p.m_b;</span></span><br><span class="line"><span class="comment">		return temp;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数重载+号</span></span><br><span class="line">person <span class="keyword">operator</span>+(person &amp;p1,person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">	person temp;</span><br><span class="line">	temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">	temp.m_b = p1.m_b + p2.m_b;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载的版本</span></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, <span class="type">int</span> p2)</span><br><span class="line">&#123;</span><br><span class="line">	person temp;</span><br><span class="line">	temp.m_a = p1.m_a + p2;</span><br><span class="line">	temp.m_b = p1.m_b + p2;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p1;</span><br><span class="line">	p1.m_a = <span class="number">10</span>;</span><br><span class="line">	p1.m_b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	person p2;</span><br><span class="line">	p2.m_a = <span class="number">10</span>;</span><br><span class="line">	p2.m_b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数重载本质调用：</span></span><br><span class="line"><span class="comment">//  person p3=p1.operator+（p2）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载的本质调用</span></span><br><span class="line"><span class="comment">//	person p3=operator+(p1,p2)</span></span><br><span class="line"></span><br><span class="line">	person p3 = p1 + p2;<span class="comment">//简化版本</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_a=&quot;</span> &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_b=&quot;</span> &lt;&lt; p3.m_b&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载也可以发生函数重载</span></span><br><span class="line">	person p4 = p1 + <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4.m_a=&quot;</span> &lt;&lt; p4.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4.m_b=&quot;</span> &lt;&lt; p4.m_b &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移运算符重载	可以让自定义的数据类型相加	operator&lt;&lt;</span></span><br><span class="line"><span class="comment">//				</span></span><br><span class="line"><span class="comment">// 1.全局函数重载&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);<span class="comment">//本质是函数也可以友元，提供构造函数进行初始化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; m_a = a; m_b = b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数重载&lt;&lt;	(因为无法实现cout在左侧，所以不会利用成员函数重载&lt;&lt;运算符）</span></span><br><span class="line">	<span class="comment">//person operator&lt;&lt;(cout)	=	p&lt;&lt;cout</span></span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能运用全局函数重载&lt;&lt;</span></span><br><span class="line"><span class="comment">// cout是标准的输出流对象，类型是ostream（输出流）而且全局只能有一个，所以要引用</span></span><br><span class="line"><span class="comment">// cin是标准的输入流对象，类型是istream（输入流）而且全局只能有一个，所以要引用</span></span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, person&amp; p)<span class="comment">//iostream的拷贝函数不允许使用，所以值返回时要引用，直接返回Ostream类型地址的cout</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//这里的&amp;cout可以使用其他别名，如&amp;aaa，因为实际传入的实参是cout</span></span><br><span class="line">	cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;<span class="comment">//如果不返回cout，则cout无法使用链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="comment">//p1.m_a = 10;</span></span><br><span class="line">	<span class="comment">//p1.m_b = 20;</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数重载的本质调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递增运算符重载++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个整形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; cout, MyInteger p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_a = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成员函数重载++</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		m_a++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//这个int是占位参数，编译器用来区分前置和后置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.记录传入时的数据</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2.进行++操作</span></span><br><span class="line">		m_a++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3.返回记录的数据</span></span><br><span class="line">		<span class="keyword">return</span> temp;<span class="comment">//因为我们返回的是在栈区的临时对象副本，这个++函数执行完会销毁，所以不能引用返回和接收</span></span><br><span class="line">		<span class="comment">//临时对象是右值，不能进行引用，不可修改</span></span><br><span class="line">		<span class="comment">//因此不能链式,如果开辟到堆区呢？实测不行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载左移运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; cout, MyInteger p)<span class="comment">//因为我们返回的是在栈区的临时对象副本，这个函数执行完会销毁，所以不能引用返回和接收</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyInteger p;</span><br><span class="line">	cout &lt;&lt; ++(++p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyInteger p;</span><br><span class="line">	cout &lt;&lt; p++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器自身提供的是浅拷贝</span></span><br><span class="line"><span class="comment">//m_age=p.m_age</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (m_age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	person&amp; <span class="keyword">operator</span>=(person &amp;p)<span class="comment">//不能使用值传递，不然会生成副本复制，将m_age的指针复制，然后结束后析构，这样就释放了堆区，后面再释放p1p2的就会出错</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//p1 = p2;直接赋值就是浅拷贝，两次释放了堆区</span></span><br><span class="line">	p3=p2 = p1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄是：&quot;</span> &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄是：&quot;</span> &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄是：&quot;</span> &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//关系运算符重载</span></span><br><span class="line"><span class="comment">//让两个自定义类型对象进行对比操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(string name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">		m_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	string m_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> ==(person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_age == p.m_age &amp;&amp; m_name == p.m_name)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载!=</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_age != p.m_age|| m_name != p.m_name)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>,<span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">person <span class="title">p3</span><span class="params">(<span class="string">&quot;王五&quot;</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1 == p2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1 != p3)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul>
<li>函数调用运算符 () 也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用运算符重载()</span></span><br><span class="line"><span class="comment">//由于重载后的使用方式非常像函数的调用，也叫仿函数（没有固定写法，非常灵活）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印函数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//重载函数运算符</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint m1;</span><br><span class="line">	<span class="built_in">m1</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">//由于重载后的使用方式非常像函数的调用，也叫仿函数</span></span><br><span class="line">	<span class="built_in">test2</span>(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿函数没有固定写法，非常灵活</span></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> c = a + b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd A1;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">A1</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名函数对象 类名（）	使用完之后立即销毁，不用实例化对象就可以使用仿函数</span></span><br><span class="line">	cout &lt;&lt;<span class="built_in">MyAdd</span>() (<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test3</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>我们发现，定义这些类，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们定义类的时候，类和类之间有特殊关系，下级别的成员除了有自己的特性，也有上级的共性</span></span><br><span class="line"><span class="comment">//利用继承可以减少重复代码</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//语法：class 子类 ：继承方式 父类</span></span><br><span class="line"><span class="comment">// 子类  也称为  派生类</span></span><br><span class="line"><span class="comment">// 父类  也称为  基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如网站有公共的头部和底部，只有中心内容不一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foorter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图....（公共底部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">laft</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c++、java、python....(公共分类列表）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java的学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foorter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图....（公共底部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">laft</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c++、java、python....(公共分类列表）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python的学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承实现页面	在需要继承的子类名后面加上 :public 父类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//公共页面类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basepage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foorter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图....（公共底部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">laft</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c++、java、python....(公共分类列表）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java1</span> :<span class="keyword">public</span> basepage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java的学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">python1</span> :<span class="keyword">public</span> basepage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;python的学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span><span class="comment">//Java页面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java的下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	java1 ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">laft</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	ja.<span class="built_in">foorter</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span><span class="comment">//Python页面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python的下载视频页面如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	python1 py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">laft</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	py.<span class="built_in">foorter</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>继承的好处：可以减少重复的代码</p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式 父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/25/66518b61e8c64.png"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方式（父类的私有内容不可继承）</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 公有继承	直接拷贝公有和保护内容</span></span><br><span class="line"><span class="comment">// 保护继承	拷贝公有和保护内容变成保护内容</span></span><br><span class="line"><span class="comment">// 私有继承	拷贝公有和保护内容变成私有内容</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span> :<span class="keyword">public</span> baes1<span class="comment">//公有继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员 到子类中依然是公共权限</span></span><br><span class="line">		m_B = <span class="number">20</span>;<span class="comment">//父类中的保护权限成员 到子类中依然是保护权限</span></span><br><span class="line">		<span class="comment">//m_C=30;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son2</span> :<span class="keyword">protected</span> baes1<span class="comment">//保护继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员 到子类中变成保护权限</span></span><br><span class="line">		m_B = <span class="number">20</span>;<span class="comment">//父类中的保护权限成员 到子类中依然是保护权限</span></span><br><span class="line">		<span class="comment">//m_C=30;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son3</span> :<span class="keyword">private</span> baes1<span class="comment">//私有继承</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员 到子类中变成私有权限</span></span><br><span class="line">		m_B = <span class="number">20</span>;<span class="comment">//父类中的保护权限成员 到子类中依然是私有权限</span></span><br><span class="line">		<span class="comment">//m_C=30;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son3 <span class="comment">//公有继承 私有继承的类 （孙子公有继承爷爷私有继承给父亲的内容)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//m_A = 10;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">		<span class="comment">//m_B = 20;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">		<span class="comment">//m_C = 30;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son1 s1;</span><br><span class="line">	s1.m_A = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">//s1.m_B = 100;	公有继承后保护权限还是保护权限，不可在类外访问</span></span><br><span class="line"></span><br><span class="line">	son2 s2;</span><br><span class="line">	<span class="comment">//s2.m_A = 100;	保护继承后全部变成保护权限，不可在类外访问</span></span><br><span class="line"></span><br><span class="line">	son3 s3;</span><br><span class="line">	<span class="comment">//s3.m_A = 100;	保护继承后全部变成私有权限，不可在类外访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从父类继承过来的成员，哪些属于子类对象中？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> baes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//16</span></span><br><span class="line">	<span class="comment">// 父类中所以的非静态成员属性都会被子类继承下去</span></span><br><span class="line">	<span class="comment">// 父类中私有成员属性  是被编译器隐藏了，因此是访问不到，但是确实被继承下去了（隐形基因？继承了压缩包但不知道密码？）</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在开始菜单里可以找到VS的开发人员命令提示符</span></span><br><span class="line"><span class="comment">// 打开之后先跳cpp所在的转盘符  如 C:</span></span><br><span class="line"><span class="comment">// cd 粘贴cpp所在地址 （cd是跳转</span></span><br><span class="line"><span class="comment">// 输入dir</span></span><br><span class="line"><span class="comment">// cl /d1 reportSingleClassLayout想查看的类名 cpp的部分名 加TAB键补全cpp</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><strong>利用工具查看</strong></p>
<ol>
<li>在开始菜单里可以找到VS的开发人员命令提示符</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/26/6652b26e1919f.png" style="zoom:50%;" /></li>
<li>打开之后先跳cpp所在的转盘符  如 C:</li>
<li>cd 粘贴cpp所在地址 （cd是跳转</li>
<li>输入dir</li>
<li><code>cl /d1 reportSingleClassLayout</code>想查看的类名 cpp的部分名 加TAB键补全cpp</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/26/6652b25d23ce0.png"></p>
<p><strong>之后就可以得到：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/26/6652b25d80306.jpg"></p>
<ul>
<li><strong>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</strong></li>
</ul>
<h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类继承父类之后，当子类创建对象，也会调用父类的构造函数</span></span><br><span class="line"><span class="comment">//父类和子类的构造和析构谁先谁后？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">baes</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;父类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">baes</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;父类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>:<span class="keyword">public</span> baes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;子类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;子类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="comment">//父类的构造函数	先创造父类才能继承</span></span><br><span class="line">	<span class="comment">//子类的构造函数	在创造子类并继承</span></span><br><span class="line">	<span class="comment">//子类的析构函数	栈区先进后出，完成操作后析构</span></span><br><span class="line">	<span class="comment">//父类的析构函数	栈区先进后出，完成操作后析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//结论：</span></span><br><span class="line">	<span class="comment">// 1.构造	先有爸爸再有儿子</span></span><br><span class="line">	<span class="comment">// 2.析构	白发人送黑发人</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<ol>
<li>​	构造	先有爸爸再有儿子</li>
<li>​	析构	白发人送黑发人</li>
</ol>
<h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类出现同名的成员，如何通过子类对象访问子类或者父类中同名的数据？</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 访问子类对象		直接访问即可</span></span><br><span class="line"><span class="comment">// 访问父类对象		需要加作用域</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	<span class="type">int</span> phone=<span class="number">188133</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是练习时长两年半的个人练习生蔡徐坤&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//同名重载函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">100</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是练习时长两年半的个人练习生坤坤&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>:<span class="keyword">public</span> baes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="type">int</span> phone=<span class="number">123456</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;卧槽，是鸡哥！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	son s1;</span><br><span class="line">	cout&lt;&lt;s1.baes::m_name&lt;&lt;endl;<span class="comment">//如果通过子类对象访问父类中的同名成员变量需要加作用域</span></span><br><span class="line">	cout&lt;&lt;s1.baes::phone&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;s1.m_name&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;s1.phone&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//成员函数</span></span><br><span class="line">	s1.baes::<span class="built_in">abc</span>();<span class="comment">//如果通过子类对象访问父类中的同名成员函数需要加作用域</span></span><br><span class="line">	s1.<span class="built_in">abc</span>();</span><br><span class="line">	s1.<span class="built_in">abc</span>();</span><br><span class="line">	<span class="comment">//s1.abc(100)</span></span><br><span class="line">	<span class="comment">// 如果子类中出现和父类同名的成员函数，子类的同名成员函数会因此掉父类中所有同名函数（重载）</span></span><br><span class="line">	<span class="comment">// 如果想要访问父类中被隐藏的同名成员函数，需要加作用域</span></span><br><span class="line">	s1.baes::<span class="built_in">abc</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中同名的静态成员在子类对象上如何访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员和非静态成员出现同名，处理方式一致</span></span><br><span class="line"><span class="comment">// 访问子类同名  直接访问</span></span><br><span class="line"><span class="comment">// 访问父类同名  加作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> string a;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是父类静态函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是父类重载静态函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>:<span class="keyword">public</span> baes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> string a;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是子类静态函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string baes::a = <span class="string">&quot;这是父类静态变量&quot;</span>;</span><br><span class="line">string son::a = <span class="string">&quot;这是子类静态变量&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问&quot;</span> &lt;&lt; endl;</span><br><span class="line">	son s1;</span><br><span class="line">	s1.<span class="built_in">b</span>();</span><br><span class="line">	s1.baes::<span class="built_in">b</span>();</span><br><span class="line">	s1.baes::<span class="built_in">b</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 如果子类中出现和父类同名的成员函数，子类的同名成员函数会因此掉父类中所有同名函数（重载,静态）</span></span><br><span class="line">	<span class="comment">//如果想要访问父类中被隐藏的同名成员函数，需要加作用域</span></span><br><span class="line">	cout &lt;&lt; s1.a &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; s1.baes::a &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	<span class="comment">//第一个::代表通过类名方式访问	第二个::代表访问父类作用域下</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问&quot;</span> &lt;&lt; endl;</span><br><span class="line">	son::<span class="built_in">b</span>();</span><br><span class="line">	son::baes::<span class="built_in">b</span>();</span><br><span class="line">	son::baes::<span class="built_in">b</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; son::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; son::baes::a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</strong></p>
<h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//c++允许一个类继承多个类（吕布：这个我熟（狗头））</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 语法 class 子类 ：继承方式 父类1  ，继承方式 父类2， .....</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 多继承可能会引发父类中有同名成员出现，需要加作用域区分</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 实际开发中不建议用多继承</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">baes2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> A = <span class="number">200</span>;</span><br><span class="line">	<span class="type">int</span> B = <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>:<span class="keyword">public</span> baes1,<span class="keyword">public</span> baes2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C = <span class="number">300</span>;</span><br><span class="line">	<span class="type">int</span> D = <span class="number">300</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son s1;</span><br><span class="line">	cout &lt;&lt; s1.B &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;s1.A&lt;&lt;endl;	出现两个父类中有同名的情况，会导致对象不明确（二义性），需要加作用域</span></span><br><span class="line">	cout &lt;&lt; s1.baes1::A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</strong></p>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p> 两个派生类继承同一个基类</p>
<p> 又有某个类同时继承者两个派生类</p>
<p> 这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</li>
<li>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//菱形继承（砖石继承）</span></span><br><span class="line"><span class="comment">//爷爷：我有2个儿子</span></span><br><span class="line"><span class="comment">//孙子：我有2个爸爸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题：1.二义性	2.孙子继承了爷爷的两份数据，但是我们只要一份就可以了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//利用虚继承  可以解决菱形继承问题</span></span><br><span class="line"><span class="comment">// 在继承之前加上关键字 virtual 变成虚继承 父类称为 虚基类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuo</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheeptuo</span> :<span class="keyword">public</span> sheep, <span class="keyword">public</span> tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sheeptuo st;<span class="comment">//(二义性)</span></span><br><span class="line">	st.sheep::age = <span class="number">18</span>;</span><br><span class="line">	st.tuo::age = <span class="number">28</span>;</span><br><span class="line">	<span class="comment">//当菱形继承，两个父类拥有相同的数据，需要加以作用域区分</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这份数据我们知道 只要有一份就可以了，菱形继承导致数据有两份，资源浪费</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//虚继承之后，数据只有一份</span></span><br><span class="line">	cout &lt;&lt; st.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/26/6652b25d82541.jpg"></p>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
<li>子类再继承的时候也是传的虚基类指针，无论多少成员都是通过指针找到的都是一开始继承的对象的唯一值</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//多态是面向对象的三大特性之一</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1.静态多态	函数重载和运算符重载 ，复用函数名	函数地址早绑定-编译阶段确定函数地址</span></span><br><span class="line"><span class="comment">// 2.动态多态	派生类和虚函数实现运行时多态		函数地址晚绑定-运行阶段确定函数地址</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//动态多态的满足条件</span></span><br><span class="line"><span class="comment">//1.有继承关系</span></span><br><span class="line"><span class="comment">//2.子类要重写父类的虚函数	返回返回值类型 函数名 参数列表 完全相同</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="comment">// 父类的引用或者指针 指向 子类对象</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span><span class="comment">//如果不加virtual，就是重复函数名，函数的地址在编译的时候就已经绑定，在运行的时候调用这个函数就会执行这个地址下的实现</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>:<span class="keyword">public</span> animal </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> :<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dospeak</span><span class="params">(animal Animal)</span><span class="comment">// animal&amp; Animal = dog 父类引用指向子类对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal.<span class="built_in">speak</span>();<span class="comment">//通过虚函数继承之后，speak的函数地址就不确定了，需要在运行的时候绑定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dog d1;</span><br><span class="line">	cat c1;</span><br><span class="line">	<span class="built_in">dospeak</span>(d1);</span><br><span class="line">	<span class="built_in">dospeak</span>(c1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>底层原理：</strong></li>
</ul>
<p>在父类定义了一个虚函数的时候，会生成一个虚函数（表）指针和虚函数表</p>
<p>指针在类内，内存为4，表不在类内，需要指针指向</p>
<p>虚函数表在记录了指向该类中所有虚函数的指针</p>
<p>继承的时候，子类也会继承虚函数表和虚函数（表）指针</p>
<p>但是在子类中重写虚函数的时候，子类中虚函数表中原本父类的虚函数的指针就会被覆盖</p>
<p>但是父类中的虚函数表不变</p>
<p>当父类的指针或者引用指向子类对象的时候，会通过虚函数（表）指针来确定被传入类中的虚函数表</p>
<p>如果被传入类中的虚函数表没有重写，就会通过里面原本记录的父类的虚函数的指针找到虚函数并且执行</p>
<p>如果被传入类中的虚函数表已经重写，就会通过里面子类的虚函数的指针找到虚函数并且执行</p>
<p><strong>以父类的指针或者引用进行传入以本人的理解就是</strong></p>
<p>1.以父类的虚函数作为公共接口，即使子类中虚函数是私有的也可以通过父类的虚函数进行访问执行（已检验可实现）</p>
<p>2.如果以值传递的方式，那么只是传递了一个副本，编译器会认为是父类的对象，不会进行多态，直接执行父类的函数</p>
<p>3.子类继承父类，子类中必然有虚函数，调用虚函数需要通过虚函数表指针，父子类的虚函数表指针指向的虚函数表不同，但指针名相同？当传入的是子类的时候，会以子类的虚函数表指针为准，找到执行子类虚函数(指针名是否相同还没有在网上找到答案，但是我通过开发人员命令提示符中是相同的)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/27/66544aeaf40f9.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/27/66544a028704e.jpg"></p>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为抽象类</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在多态中，通常父类中虚函数是毫无意义的，主要作用是调用子类重写的内容</span></span><br><span class="line"><span class="comment">//因此可以将虚函数该为纯虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法： virtual 返回值类型 函数名 （形参列表）=0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当类中有了纯虚函数，这个类也叫抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特点：</span></span><br><span class="line"><span class="comment">//无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写抽象类中的纯虚函数，否则也叫抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>  <span class="comment">//当类中有了纯虚函数，这个类也叫抽象类</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span>:<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;12456&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//animal a;//无法实例化对象</span></span><br><span class="line">	<span class="comment">//new animal;//无法实例化对象</span></span><br><span class="line"></span><br><span class="line">	sheep a1;<span class="comment">//子类必须重写纯虚函数，否则是抽象类，无法实例化对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(animal&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sheep s1;</span><br><span class="line">	<span class="built_in">test2</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象(类内声明，类外实现)</li>
</ul>
<p>虚析构语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ~类名()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>纯虚析构语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual ~类名() = 0;</span><br><span class="line">类名::~类名()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态在使用的时候，如果有子类中有属性开辟到堆区，那么父类指针在释放的时无法调用到子类的析构代码</span></span><br><span class="line"><span class="comment">//通过将父类中的析构函数改为虚析构或者纯虚析构可以解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚析构和纯虚析构的共性</span></span><br><span class="line"><span class="comment">//可以解决父类指针释放子类对象</span></span><br><span class="line"><span class="comment">//都需要有具体的函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//如果是纯虚析构，该类属于抽象类，无法实例化对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="comment">// 纯虚析构(类内声明，类外实现)</span></span><br><span class="line"><span class="comment">// virtual ~类名()=0;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 虚析构</span></span><br><span class="line"><span class="comment">//virtual ~类名()&#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt; <span class="string">&quot;父类的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//虚析构</span></span><br><span class="line">	<span class="comment">/*virtual~animal()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;父类的析构函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 纯虚析构(类内声明，类外实现)	(有了</span></span><br><span class="line">	<span class="keyword">virtual</span>~<span class="built_in">animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">animal::~<span class="built_in">animal</span>() &#123; cout &lt;&lt; <span class="string">&quot;父类的析构函数调用&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> :<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dog</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;子类的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt;*m_name&lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	string* m_name;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">dog</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_name != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;子类的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">delete</span> m_name;</span><br><span class="line">			m_name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dospeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal* animal1 = <span class="keyword">new</span> <span class="built_in">dog</span>(<span class="string">&quot;卧槽&quot;</span>);</span><br><span class="line">	animal1-&gt;<span class="built_in">speak</span>();</span><br><span class="line">	<span class="keyword">delete</span> animal1;<span class="comment">//因为dog开辟在堆区，如果不销毁，dog的析构函数就一直不会执行，因为dog一直存在，那么父类也会存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">dospeak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
<li>如果子类在堆区中不销毁，那么因为子类而出现的父类也不会销毁</li>
</ol>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>多态有3个案例-在案例练习区</p>
<p>计算器</p>
<p>制作饮品</p>
<p>组装电脑</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 &lt; fstream &gt;</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong> - 文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件步骤如下：</p>
<ol>
<li><p>包含头文件</p>
<p>#include <fstream></p>
</li>
<li><p>创建流对象</p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary | ios:: out</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序运行时产生的数据都属于临时数据，程序一旦运行结束都会释放</span></span><br><span class="line">	<span class="comment">//通过文件可以将数据持久化</span></span><br><span class="line">	<span class="comment">//c++中对文件操作需要包含头文件&lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件类型包含两种</span></span><br><span class="line">	<span class="comment">// 1.文本文件		文件以文本的ASCII码形式储存在计算机中</span></span><br><span class="line">	<span class="comment">// 2.二进制文件		文件以文本的二进制形式储存在计算机中，用户一般看不懂</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 操作</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 1.写操作	ofstream:</span></span><br><span class="line">	<span class="comment">// 2.读操作 ifstream:</span></span><br><span class="line">	<span class="comment">// 3.读写操作 fstream:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//写文件</span></span><br><span class="line">	<span class="comment">// 1.包含头文件 fstream</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 2.创建流对象 </span></span><br><span class="line">	ofstream ofs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.指定打开方式</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);<span class="comment">//如果不指定路径，文件就会保存在源文件路径下</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.写内容</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名;张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;电话：123456789&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序运行时产生的数据都属于临时数据，程序一旦运行结束都会释放</span></span><br><span class="line">	<span class="comment">//通过文件可以将数据持久化</span></span><br><span class="line">	<span class="comment">//c++中对文件操作需要包含头文件&lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件类型包含两种</span></span><br><span class="line">	<span class="comment">// 1.文本文件		文件以文本的ASCII码形式储存在计算机中</span></span><br><span class="line">	<span class="comment">// 2.二进制文件		文件以文本的二进制形式储存在计算机中，用户一般看不懂</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 操作</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 1.写操作	ofstream:</span></span><br><span class="line">	<span class="comment">// 2.读操作 ifstream:</span></span><br><span class="line">	<span class="comment">// 3.读写操作 fstream:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//写文件</span></span><br><span class="line">	<span class="comment">// 1.包含头文件 fstream</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 2.创建流对象 </span></span><br><span class="line">	ofstream ofs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.指定打开方式</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);<span class="comment">//如果不指定路径，文件就会保存在源文件路径下</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.写内容</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名;张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;电话：123456789&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结：<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
</li>
</ul>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件</p>
<p>#include <fstream></p>
</li>
<li><p>创建流对象</p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建流对象</span></span><br><span class="line">	ifstream ifs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开文件并判断文件是否打开成功</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())<span class="comment">//ifs.is_open 是一个布尔函数，打开成功就会返回真</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////第一种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf, sizeof(buf)))//getline是整行读取（数组地址，数组内存）</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))//全局的getline函数（基础的输入流对象，字符串）</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第四种	效率低</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)<span class="comment">//一个一个读，只要没有读到尾，就一直读 EOF =  end of file</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ios::binary</p>
<h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> m_name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创造流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">osf</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<span class="comment">//也可以写在这里，因为有构造函数直接打开文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	<span class="comment">//osf.open(&quot;person.txt&quot;,ios::out | ios::binary)</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//写文件</span></span><br><span class="line">	person p1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line">	osf.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p1, <span class="built_in">sizeof</span>(person));<span class="comment">//（传入char类型的地址，类的内存）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	osf.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> m_name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//包含头文件</span></span><br><span class="line">	<span class="comment">//创造流对象</span></span><br><span class="line">	ifstream isf;</span><br><span class="line">	<span class="comment">//打开文件并判断是否打开</span></span><br><span class="line">	isf.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line">	<span class="keyword">if</span> (!isf.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读对象</span></span><br><span class="line">	person p1;<span class="comment">//用来接收</span></span><br><span class="line">	isf.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p1, <span class="built_in">sizeof</span>(p1));<span class="comment">//指针接收因为方便字节替换，每次指针+1就是向后移动一个类型的字节</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1.m_name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p1.m_age &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	isf.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
<p>————————————————————————————————</p>
<h6 id="核心篇完结撒花"><a href="#核心篇完结撒花" class="headerlink" title="核心篇完结撒花"></a>核心篇完结撒花</h6><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/6656f81292bc3.jpg" style="zoom:50%;" />
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/19/6763fb8953276.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/19/6763fb8953276.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小楼夜听雨</div><div class="post-copyright__author_desc">天气晴朗 万物可爱</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/')">C++面向对象编程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++面向对象编程&amp;url=http://yzf522.cn/2024/05/10/%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/&amp;pic=https://bu.dusays.com/2024/12/29/677157b8efbea.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yzf522.cn" target="_blank">小楼夜听雨</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/12/29/677157dd5f26a.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/09/%E9%A1%B9%E7%9B%AE/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157b60b247.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++练习项目</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/06/%E5%89%8D%E7%AB%AF/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157b511fc0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/05/07/C++%E7%AC%94%E8%AE%B0/" title="C++基础编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157b2a8b1d.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-07</div><div class="title">C++基础编程</div></div></a></div><div><a href="/2024/05/07/C++%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/" title="c++案例练习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157cde2ecf.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-07</div><div class="title">c++案例练习</div></div></a></div><div><a href="/2024/07/18/C-%E7%BC%96%E7%A8%8B%E6%8F%90%E9%AB%98/" title="C++泛型编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157b391ee2.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-18</div><div class="title">C++泛型编程</div></div></a></div><div><a href="/2024/05/09/%E9%A1%B9%E7%9B%AE/" title="C++练习项目"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157b60b247.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-09</div><div class="title">C++练习项目</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/19/6763fb8953276.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小楼夜听雨</h1><div class="author-info__desc">天气晴朗 万物可爱</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://qm.qq.com/q/pK3YnDshmU" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-qq"></use></svg></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-text">内存分区模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D"><span class="toc-text">程序运行前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E"><span class="toc-text">程序运行后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%9C%A8%E5%A0%86%E5%8C%BA%E5%BC%80%E8%BE%9F%E6%95%B0%E7%BB%84"><span class="toc-text">new操作符和在堆区开辟数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">引用的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">引用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">引用做函数参数(引用传递)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">引用做函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-text">常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98"><span class="toc-text">函数提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">函数默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="toc-text">函数占位参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0"><span class="toc-text">函数重载概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">函数重载注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">封装的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%84%8F%E4%B9%89%E4%B8%80%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%B1%BB"><span class="toc-text">封装意义一：设计类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%84%8F%E4%B9%89%E4%BA%8C%EF%BC%9A%E5%B0%81%E8%A3%85%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">封装意义二：封装的权限控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct%E5%92%8Cclass%E5%8C%BA%E5%88%AB"><span class="toc-text">struct和class区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="toc-text">成员属性设置为私有</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="toc-text">对象的初始化和清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="toc-text">构造函数的分类及调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-text">拷贝构造函数调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">构造函数调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">类对象作为类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-text">C++对象模型和this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="toc-text">成员变量和成员函数分开存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="toc-text">this指针概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">空指针访问成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-text">全局函数做友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-text">类做友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-text">成员函数做友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">加号运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">左移运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">递增运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">赋值运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">关系运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">函数调用运算符重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">继承的基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">继承中的对象模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">继承中构造和析构顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">继承同名成员处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">继承同名静态成员处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">多继承语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-text">菱形继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">多态的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">纯虚函数和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-text">虚析构和纯虚析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">文本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">读文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">二进制文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6-1"><span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6-1"><span class="toc-text">读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AF%87%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1"><span class="toc-text">核心篇完结撒花</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/24/%E8%87%AA%E5%8A%A8%E5%BD%95%E8%AF%BE%E9%A1%B9%E7%9B%AE/" title="自动录课项目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157dd5f26a.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动录课项目"/></a><div class="content"><a class="title" href="/2025/01/24/%E8%87%AA%E5%8A%A8%E5%BD%95%E8%AF%BE%E9%A1%B9%E7%9B%AE/" title="自动录课项目">自动录课项目</a><time datetime="2025-01-24T13:22:08.000Z" title="发表于 2025-01-24 21:22:08">2025-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/24/GIS%E9%A1%B9%E7%9B%AE/" title="GIS项目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157e1ee0f2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GIS项目"/></a><div class="content"><a class="title" href="/2025/01/24/GIS%E9%A1%B9%E7%9B%AE/" title="GIS项目">GIS项目</a><time datetime="2025-01-24T13:21:23.000Z" title="发表于 2025-01-24 21:21:23">2025-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/pyqt%E5%9B%BE%E5%BD%A2%E5%8C%96/" title="pyqt图形化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157dc248fc.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pyqt图形化"/></a><div class="content"><a class="title" href="/2024/12/10/pyqt%E5%9B%BE%E5%BD%A2%E5%8C%96/" title="pyqt图形化">pyqt图形化</a><time datetime="2024-12-10T11:52:00.000Z" title="发表于 2024-12-10 19:52:00">2024-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/%E7%88%AC%E8%99%AB/" title="爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157ef96fdd.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="爬虫"/></a><div class="content"><a class="title" href="/2024/12/10/%E7%88%AC%E8%99%AB/" title="爬虫">爬虫</a><time datetime="2024-12-10T07:12:47.000Z" title="发表于 2024-12-10 15:12:47">2024-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/16/Python/" title="Python"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/29/677157b388831.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python"/></a><div class="content"><a class="title" href="/2024/11/16/Python/" title="Python">Python</a><time datetime="2024-11-16T15:44:53.000Z" title="发表于 2024-11-16 23:44:53">2024-11-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="小楼夜听雨" target="_blank">小楼夜听雨</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://localhost:4000/404.html" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://localhost:4000/404.html" title="还没想好"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="还没想好"/><span class="back-menu-item-text">还没想好</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=13091820019&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>4</sup></a><a href="/tags/Unity/" style="font-size: 0.88rem;">Unity<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>2</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 0.88rem;">网站<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="13091820019" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=13091820019&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/05/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小楼夜听雨 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4535092_538o0cuhmw7.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>